#!/usr/bin/perl


# suck


use strict;
use File::Find ();

# for the convenience of &wanted calls, including -eval statements:
use vars qw/*name *dir *prune/;
*name   = *File::Find::name;
*dir    = *File::Find::dir;
*prune  = *File::Find::prune;

#
my $src = "/tmp/spit/";
my $stg = "/tmp/stage/";
my $dst = "/tmp/destination/";
my $backup_dir = "/tmp/backup_dir/";

#

my $clmask = $ARGV[0];
my @masks;
# check for any mask dependices
open(MASK,"deploy.config");
while(<MASK>)
{
	s/\s+$//;
	my @tmasks = split (/\s+/);
	if ($tmasks[0] == 'DEFAULT' && $tmasks[$#tmasks] eq $clmask )
	{
		@masks = @tmasks[1..($#tmasks -1 )];
		last;
	}
}
close MASK;
push @masks,$clmask;

print "masks are " . join(" ",@masks) . "\n";



my @ignorefiles;

# first copy files to staging area
system "rsync --progress --verbose --compress --archive --rsh=ssh --delete $src $stg";


# Traverse desired filesystem (loop by mask or function first?)

my $mask;
foreach $mask (@masks)
{
	chdir $src; # keep it relative
	File::Find::find({wanted => \&delete}, "." );
	File::Find::find({wanted => \&rename}, "." );
	File::Find::find({wanted => \&ignore}, "." );
}

my $tmpfilename = "/tmp/" . "spit" . time . $$;
print "ignore files are:\n" . join ("\n",@ignorefiles) . "\n";
open(TMP,">$tmpfilename");
print TMP join ("\n",@ignorefiles) . "\n";
close TMP;

# now copy files from destination back into staging and capture changes.

print "rsync --progress --verbose --compress --archive --rsh=ssh --exclude-from=$tmpfilename --delete --backup --backup-dir $backup_dir $dst $stg \n" ;

open(RSYNC, "rsync --compress --archive --rsh=ssh --exclude-from=$tmpfilename --delete --log_format=\"\%f\" $dst $stg |") ;
my @changes = (<RSYNC>);
close RSYNC;

unlink $tmpfilename;

# now examine backup_dir and consider making ~, d~, i~ changes to src tree.
my $change;
foreach $change (@changes)
{
	consider_change($change);
}


exit;


sub delete {
	if ( /^(.*)\.$mask\.d~\z/s )
	{
		my $target = $1;
		my $targetpathname = $dir . "/" .  $target;
		print("$targetpathname\n");
		print "removing $stg$targetpathname\n";
		system 'rm','-rf',$stg  . $targetpathname ; 
		#(unlink($_) || warn "$name: $!\n") &&
		print("$name\n");
	}
}

sub rename {
	if ( /^(.*)\.$mask\.~\z/s )
	{
		my $target = $1;
		my $targetpathname = $dir . "/" .  $target;
		print("$targetpathname\n");
		print "removing $stg$targetpathname\n";
		system 'rm','-rf',$stg  . $targetpathname ; 
		print "renaming  $stg$name to  $stg$targetpathname\n";
		rename $stg  . $name, $stg  . $targetpathname;
		print("$name\n");
	}
}

sub ignore {
	if ( /^(.*)\.$mask\.i~\z/s )
	{
		my $target = $1;
		my $targetpathname = $dir . "/" .  $target;
		print("$targetpathname\n");
		push (@ignorefiles, $targetpathname);
	}
}


sub consider_change {
	print "remote version:\n";
	system "ls -ld $stg/$name";
	print "local version:\n";
	system "ls -ld $backup_dir/$name";
	print "src versions:\n";
	system "ls -ld $src/$name";
	print "\n";
	print "What to do? (s)kip (i)gnore (d)elete (r)eplace (q)uit\n";
	# read input
	($input = <STDIN>) =~ s/\s+$//g;
	$_ = $input;
	SWITCH: {
                if ( /^s$/ ) { last SWITCH; }
                if ( /^q$/ ) { exit 0; }
                if ( /^i$/ ) { 
			$mask = &choosemask(); 
			system "touch $src/$name.$mask.i~
			last SWITCH;
		}
                if ( /^r$/ ) { 
			$mask = &choosemask(); 
			system "mv $stage/$name $src/$name.$mask.r~
			last SWITCH;
		}
                if ( /^d$/ ) { 
			$mask = &choosemask(); 
			system "touch $src/$name.$mask.d~
			last SWITCH;
		}
                if ( /^h$/ ) { 
			print "help!\n";
			last SWITCH;
		}
	}
}

sub choosemask
{
	print "Which mask?n "; 
	my $i=0
	print map "$i++ $_\n ", @masks ;
	# now action chainge...
	while ( (($input = <STDIN>) =~ s/\s+$//g) !~ /^\d+/ ) 
	{
		print "enter a number!\n"; 
	}
	return $masks[$input];
}

