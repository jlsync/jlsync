#!/usr/local/bin/perl -w

# jlsync - not yet usable
#
# Jason Lee, jlsync@jason-lee.net.au, March 2002
#
# Copyright © 2002-2005   Jason Lee Pty. Ltd.
#
# $Id: jlsync,v 1.79 2005/11/05 22:24:31 plastic Exp $

#################### BEGIN CONFIGURATION SECTION ###########################

# path to rsync version 2.6.4 (or greater)
my $rsync = "/usr/local/bin/rsync";

# special command line options to always use with rsync
my $rsync_opts = "--rsync-path=/usr/local/bin/rsync --rsh=/usr/local/bin/ssh";

# directories variables are without trailing /
# leave $jlsyncdir set to "/jlsync" for compatibility with furture upgrades
my $jlsyncdir = "/jlsync";

# $src, $stg and $backup_dir must be on the same filesystem
my $src        = $jlsyncdir . "/source";
my $stg        = $jlsyncdir . "/stage";
my $backup_dir = $jlsyncdir . "/backup";

# jlsync config file
my $config = $jlsyncdir . "/etc/jlsync.config";

# $smtpserver is used by Mail::Mailer to send --email reports through
my $smtpserver = '127.0.0.1';

# not all filesystems are created equal. leave this set to 0
my $able_to_link_to_symlinks = 0;    # linux = 1 , solaris = 0 ;

#################### END OF CONFIGURATION SECTION ###########################

use strict;
use Cwd;
use File::Find ();                   # recent version required.
use File::Path;

# use File::stat;		# TODO: maybe use this later.
use Term::ANSIColor qw(:constants);
use File::Basename;
use Getopt::Long;
use Mail::Mailer;

# for the convenience of &wanted calls, including -eval statements:
#use vars qw/*name *dir  $mask @excludepatterns @masks/;
use vars qw/*name *dir/;
our ( $mask, @excludepatterns, @masks, $nsrc, $dest );
*name = *File::Find::name;
*dir  = *File::Find::dir;

my $reportfrom = 'jlsync report <root>';

my @controlfiles = ();    # array of control file hashes.

$| = 1;                   # turn on autoflush

my $spinpos;
my $spinning;
my $spinlen;

umask 0;                  # needed by subsequent mkdirs

my %cph;                  # Client Path Hash

my $client;
my $path;
my $verbose;
my $report;
my $email;
my $silent;
my $reporttext;
my $real;
my $get;
my $getmask;
my $nocolor;
my $unjlsyncronized = 0;

GetOptions( "real"             => \$real,       # --real
            "get"              => \$get,        # --get
            "verbose"          => \$verbose,    # --verbose
            "report"           => \$report,     # --report
            "email|mail=s"     => \$email,      # --email=address
            "nocolor|nocolour" => \$nocolor,    # --nocolor
            "mask=s"           => \$getmask,    # --mask=MASKNAME
            "silent"           => \$silent,     # --silent available on commandline for testing
          ) || &usage;

&usage unless ( defined $ARGV[0] );

foreach my $arg (@ARGV)
{
    &usage unless ( $arg =~ m|\w[\w\-]*:/| );
}

if (    ( $real && $report )
     || ( $get  && $report )
     || ( $real && $email )
     || ( $get  && $email ) )
{
    &usage;
}

$silent = 1 if $report;

foreach my $arg (@ARGV)
{
    $arg =~ m|(.+):(.+)|;
    my $clientarg = $1;
    my $path      = $2;
    my @clients   = split( ",", $1 );
    foreach my $client (@clients)
    {
        @{ $cph{$client}{$path} } = ();
    }
}

my $dryrun = $real ? "" : "--dry-run";
if ($nocolor) { $ENV{'ANSI_COLORS_DISABLED'} = 'nocolor'; }

my $excludepatternfile;
my %masks_of;
my %hosts_with;

open( CONFIG, $config ) || die "can not open $config";
while (my $config_line = <CONFIG>)
{
    next if $config_line =~ /^#/;
    $config_line =~ s/\s+$//;
    my @tmasks    = split(/\s+/,$config_line);
    my $this_host = $tmasks[-1];    # host is last mask on line
    if ( $tmasks[0] eq 'DEFAULT' )
    {
        if ( defined $masks_of{$this_host} )
        {
            print BOLD . RED . "Error: duplicate entires for $this_host is file $config . exiting." . RESET . "\n";
            exit 1;
        }
        else
        {
            $masks_of{$this_host} = \@tmasks;
            foreach my $mask (@tmasks)
            {
                push @{ $hosts_with{$mask} }, $this_host;
            }
        }
    }
}
close CONFIG;

foreach $client ( keys %cph )
{
    if ( $client =~ /^=(.*)/ )    # leading = is stripped off here
    {
        my @intersect_masks = split /=/, $1;
        foreach my $mask (@intersect_masks)
        {
            unless ( defined $hosts_with{$mask} )
            {
                print "$mask not found in file $config. exiting.\n";
                exit 1;
            }
        }

        my $firstmask = shift @intersect_masks;
        my %intersection = map { ( $_, 1 ) } @{ $hosts_with{$firstmask} };
        foreach $mask (@intersect_masks)
        {
            print "updated $client intersection is now " . ( join " ", ( keys %intersection ) ) . "\n" if $verbose;
            foreach my $host ( keys %intersection )
            {
                unless ( grep /^$host$/, @{ $hosts_with{$mask} } )
                {
                    delete $intersection{$host};
                }
            }
        }

        print "for client $client intersection of matching hosts is " . ( join " ", ( keys %intersection ) ) . "\n" if $verbose;

        # now update %cph
        my $path = $cph{$client};
        delete $cph{$client};
        foreach my $host ( keys %intersection )
        {
            $cph{$host} = $path;
        }
    }
    elsif ( !defined $masks_of{$client} )
    {
        print "$client not found in file $config. exiting.\n";
        exit 1;
    }
}

foreach $client ( keys %cph )
{
    my $lockfile = "$stg/${client}-lock";
    if ( -f $lockfile )
    {
        print "jlsync currently locked ( $lockfile ) by process id ";
        system "cat", $lockfile;
        print "\n";
        exit 1;
    }
}

foreach $client ( keys %cph )
{
    my $lockfile = "$stg/${client}-lock";
    open( LOCK, ">$lockfile" ) || die "could not create lockfile: $lockfile";
    print LOCK $$;
    close LOCK;
}

print "reading source repository image in... " unless $silent;
my %srch = &srcdir($src);
nospin()        unless $silent;
print "done.\n" unless $silent;

foreach $client ( keys %cph )
{
    &buildstageclient($client);
}

foreach $client ( keys %cph )
{
    foreach $path ( keys %{ $cph{$client} } )
    {

        if ( @{ $cph{$client}{$path} } )
        {
            my @excludepatterns = @{ $cph{$client}{$path} };

            print "exclude patterns for " . CYAN . BOLD . $client . ":" . $path . RESET . " are:\n" . ON_CYAN . "\n" . join( "\n", @excludepatterns ) . "\n" . RESET . "\n"
                unless $silent;

            $excludepatternfile = "/tmp/" . ".jlsync-" . $client . "-" . time . "-" . $$;

            open( TMP, ">$excludepatternfile" )
                || die "could not open $excludepatternfile";
            print TMP join( "\n", @excludepatterns ) . "\n";
            close TMP;
        }
        else
        {
            print "there are no exclude patterns for " . CYAN . BOLD . $client . ":" . $path . RESET . "\n" unless $silent;
            undef $excludepatternfile;
        }

        if ($get)
        {
            &get( $client, $path );
        }
        else
        {
            &deploy( $client, $path );
        }

        if ( defined($excludepatternfile) )
        {
            unlink $excludepatternfile;
        }
    }
}

foreach $client ( keys %cph )
{
    my $lockfile = "$stg/${client}-lock";
    unlink $lockfile;
}

if ($report)
{
    my $rl = <<END;
rsync --itemize legend: UXcstpoga
action U: <)send  >)receive  c)change/create  h)hardlink  .)attribute chanage
file-types X: f)file  d)directory  L)symlink  D)device
why: c)hecksum s)ize t)imestamp p)ermissions o)wner g)roup a)extended attribute
END

    my $runtime = time - $^T;
    $reporttext = "jlsync report at " . localtime(time) . "\n\n" . ( $unjlsyncronized > 0 ? $rl . "\n\n" : "" ) . $reporttext . "\nEnd of report. Completed in " . $runtime . " seconds.\n";

    if ($email)
    {
        my $sinfo =
            ( $unjlsyncronized > 0 )
            ? " - out of sync: " . $unjlsyncronized
            : " - fully jlsyncronized";

        my $mailer = Mail::Mailer->new( 'smtp', Server => $smtpserver );
        $mailer->open( { From    => $reportfrom,
                         To      => $email,
                         Subject => 'jlsync report at ' . localtime(time) . $sinfo
                       }
                     );
        print $mailer $reporttext;
        $mailer->close();
    }
    else
    {
        print $reporttext;
    }
}

exit 0;

######################################################

# datastructure
# directory hash { fileone => filehash,  filetwo => filehash }
# filehash { lstat => (normal lstat array),
#	     type => "f" or "d" or "l",
#	     srcpath => "/src/dir/full/path",
#	     dir => dirhash ,
#            link => "link/target" ,
#  ????      control => {
#                         a => { maska => filehash, maskb => filehas, ... }
#                         d => { maska => filehash, maskb => filehas, ... }
#                         e => { maska => filehash, maskb => filehas, ... }
#                        }
#            }

sub srcdir
{
    my $dir = $_[0];
    my %dirh;
    local *DIR;

    #opendir(DIR,$src . "/" . $ap) || die "could not open $ap \! \n";
    opendir( DIR, $dir ) || die "could not open $dir \! \n";
    my $nextfile;
    while ( defined( $nextfile = readdir(DIR) ) )
    {
        next if $nextfile =~ /^\.\.?$/;
        $dirh{$nextfile} = { &srcfile( $dir . "/" . $nextfile ) };
    }
    close(DIR);
    spin() unless $silent;
    return %dirh;
}

sub srcfile
{
    my $filename = $_[0];
    my %fileh;

    $fileh{srcpath} = $filename;
    $fileh{lstat}   = [ lstat $filename ];

    if ( -f _ )
    {
        print "$filename is a file\n" if $verbose;
        $fileh{type} = 'f';
    }
    elsif ( -d _ )    # -d on symlink to a dir will succeed on linux/ext2fs
    {
        print "$filename is a dir\n" if $verbose;
        $fileh{type} = 'd';
        $fileh{dir}  = { &srcdir($filename) };
    }
    elsif ( -l _ )
    {
        print "$filename is a symlink\n" if $verbose;
        $fileh{type}     = 'l';
        $fileh{readlink} = readlink($filename);
    }
    else
    {
        print "not a file, symlink or directory: $filename\n";
    }
    return %fileh;
}

sub usage
{
    print "jlsync usage:\n";
    print "jlsync [--real] [--nocolor] [--verbose ] client:/path/to/pushout [more:/client/path/pairs]\n";
    print "jlsync --get [--mask=MASK] [--real] [--nocolor] [--verbose ] client:/path/to/pullback\n";
    exit 1;
}

sub buildstageclient
{
    my $client = $_[0];
    @masks = @{ $masks_of{$client} };    # @masks is a global var

    print "masks are " . BLUE . BOLD . join( " ", @masks ) . RESET . ".\n"
        unless $silent;

    my $stgclient = "$stg/$client";
    print "deleting old image for $client in $stgclient ... " unless $silent;
    system "/bin/rm -rf $stgclient";
    if ( $? != 0 ) { die "could not /bin/rm -rf $stgclient"; }
    print "done.\n" unless $silent;
    mkdir "$stgclient", 0755 or die "could not mkdir $stgclient";

    print "building new image for $client in $stgclient ...\n" unless $silent;

    foreach my $path ( keys %{ $cph{$client} } )
    {
        @{ $cph{$client}{$path} } = &buildstagepath( $client, $path );
    }
    utime( time, ( stat($src) )[9], $stgclient );

    nospin() unless $silent;
    print "done building new image for $client in $stgclient\n" unless $silent;
}

sub buildstagepath
{
    my $client = $_[0];
    my $path   = $_[1];

    $path =~ s|^/||;

    my @excludepatterns = &rbuildstagepath( $masks_of{$client}, \%srch, $path, "$stg/$client" );
    my $stgclient = "$stg/$client";
    @excludepatterns = map { $_ =~ s|^\Q$stgclient||; $_ } @excludepatterns;
    return @excludepatterns;
}

# rbuildstagepath - recursive build stage path
#
sub rbuildstagepath
{
    my $masksref = $_[0];    # reference to array of client masks as listed jlsync.config
    my $srch     = $_[1];    # reference to source hash rooted at current directory level
    my $path     = $_[2];    # string containing "remaining/path/to/process"
    my $dest     = $_[3];    # full path of destination directory for remaining build

    my @masks = [$masksref];
    my @excludepatterns;
    my $filesaref;
    my $excludearef;

    if ( defined($path) )    # still some remaining path to selectively process.
    {
        my @pcs    = split "/", $path;
        my $nextpc = shift @pcs;

        # selectively filter controlfiles....
        ( $filesaref, $excludearef ) = &filtercontrolfiles( [ keys %{$srch} ], $nextpc, $srch );

        $path = join "/", @pcs;    # remaining path.
    }
    else
    {
        ( $filesaref, $excludearef ) = &filtercontrolfiles( [ keys %{$srch} ], undef, $srch );
    }

    @excludepatterns = map { $dest . "/" . $_ } @{$excludearef};

    foreach my $srcname ( @{$filesaref} )
    {
        my $stgname = $srcname;

        #print "srcname is $srcname \n";
        #print "type is  $srch->{$srcname}{type} \n";
        #print "lstat is " . join(",", $srch->{$srcname}{lstat}) . "\n";
        #print "dir is " .  $srch->{$srcname}{dir} . "\n";
        #print "readlink is " .  $srch->{$srcname}{readlink} . "\n";

        if ( $stgname =~ m|(.*)\.\w[\w\-\,]*\.a\~$| )
        {
            $stgname = $1;
        }
        my $destname = "$dest/$stgname";

        if ( $srch->{$srcname}{type} eq "f" )
        {
            print "$srcname is a file\n" if $verbose;
            link( $srch->{$srcname}{srcpath}, $destname )
                || die "unable to link $srch->{$srcname}{srcpath} to $destname";
        }
        elsif ( $srch->{$srcname}{type} eq "d" )
        {
            print "$srcname is a dir\n" if $verbose;
            my ( $mode, $uid, $gid, $mtime ) = @{ $srch->{$srcname}{lstat} }[ 2, 4, 5, 9 ];
            if ( !-d $destname )
            {
                $mode = $mode & 07777;    # mask off file type
                mkdir $destname, $mode || die "unable to mkdir $destname";
                chown $uid, $gid, $destname;
            }
            push( @excludepatterns, &rbuildstagepath( $masksref, $srch->{$srcname}{dir}, $path, $destname ) );
            utime( time, $mtime, $destname );

        }
        elsif ( $srch->{$srcname}{type} eq "l" )
        {

            # Need some special code here to handle copying or
            # hardlink of relative symlinks

            print "$srcname is a symlink\n" if $verbose;
            if ($able_to_link_to_symlinks)
            {
                link( $srch->{$srcname}{srcpath}, $destname )
                    || die "unable to link $srch->{$srcname}{srcpath} to $destname";
            }
            else
            {

                # deference symlink
                my $target = $srch->{$srcname}{readlink};

                # create new symlink like original
                symlink( $target, $destname )
                    || die "unable to symlink $target to $destname";

                # set timestamp - this doesn't work sets time stamp on target of link not symlink itself. rsync seems to be ignoring symlink timestamps anyway.
                # my $mtime =  @{$srch->{$srcname}{stat}}[ 9 ];
                # utime(time, $mtime, $destname);
            }
        }
        else
        {
            print "not a file, symlink or directory: $srcname\n";
        }
    }
    return @excludepatterns;
}

sub filtercontrolfiles
{
    my @newlist        = @{ $_[0] };
    my $basenamefilter = $_[1];
    my $srchref        = $_[2];

    if ( defined($basenamefilter) )
    {
        @newlist = grep /^$basenamefilter/, @newlist;
    }

    @newlist = sort @newlist;
    my @excludepatterns;

    if ($verbose)
    {
        print "predir is $dir\n";
        print "newlist is " . ( join ",", @newlist ) . "\n";
    }
    else
    {
        spin();
    }

    foreach $mask ( reverse @masks )
    {
        my @alist = grep /\.(\w[\w\-]*,)*$mask(,\w[\w\-]*)*\.a~$/, @newlist;
        my $a;
        foreach $a (@alist)
        {
            nospin() unless $silent;

            # TODO : add symlink add/print case below
            print GREEN . "add:$srchref->{$a}->{srcpath}" . ( $srchref->{$a}->{type} eq "d" ? "/" : "" ) . RESET . "\n" unless $silent;
            ( my $basename = $a ) =~ s/\.(\w[\w\-]*,)*$mask(,\w[\w\-]*)*\.a~$//;
            @newlist = grep !/^\Q$basename\E$/, @newlist;
            @newlist = grep !/^\Q$basename\E\.\w[\w\-]*(,\w[\w\-]*)*\.[ade]\~$/, @newlist;
            push( @newlist, $a );
        }

        my @dlist = grep /\.(\w[\w\-]*,)*$mask(,\w[\w\-]*)*\.d~$/, @newlist;
        my $d;
        foreach $d (@dlist)
        {
            nospin() unless $silent;

            # bug on this next line. we want to test file type (is it a directory?) of control file target, not control file itself.
            print RED . "del:$srchref->{$d}->{srcpath}" . ( $srchref->{$d}->{type} eq "d" ? "/" : "" ) . RESET . "\n" unless $silent;
            ( my $basename = $d ) =~ s/\.(\w[\w\-]*,)*$mask(,\w[\w\-]*)*\.d~$//;
            @newlist = grep !/^\Q$basename\E$/, @newlist;
            @newlist = grep !/^\Q$basename\E\.\w[\w\-]*(,\w[\w\\-]*)*\.[ade]\~$/, @newlist;
        }

        my @elist = grep /\.(\w[\w\-]*,)*$mask(,\w[\w\-]*)*\.e~$/, @newlist;
        my $e;
        foreach $e (@elist)
        {
            print "e~ is $e\n" if $verbose;
            ( my $basename = $e ) =~ s/\.(\w[\w\-]*,)*$mask(,\w[\w\-]*)*\.e~$//;
            @newlist = grep !/^\Q$basename\E$/, @newlist;
            @newlist = grep !/^\Q$basename\E\.\w[\w\-]*(,\w[\w\-]*)*\.[ade]\~$/, @newlist;

            #my $targetdir = join ("/" ,  (map  { $_ =~ s/\.\w[\w\-,]*\.a~$/$1/ ; $_ }   split("/",$dir) )  );
            ##my $targetdir = $dir;
            ##$targetdir =~ s|\.\w[\w\-,]*\.a~/|/|;
            ##$targetdir =~ s|\.\w[\w\-,]*\.a~$||;
            ##push(@excludepatterns, $targetdir . "/" . $basename);

            push( @excludepatterns, $basename );
        }
    }

    # strip out any remaining control files for other non-matched masks while preserving .a~ files.
    my @newnewlist = ();
    FILE: 
    foreach my $file (@newlist)
    {
        if ( $file =~ /\.(\w[\w\-\,]*)\.a\~$/ )   
        {
            my @file_masks = split( ",", $1 );
            foreach my $fm (@file_masks)
            {
                if ( grep /^$fm$/, @masks )
                {
                    push( @newnewlist, $file );
                    last FILE;
                }
            }
        }
        elsif ( $file =~ /\.[ed]\~$/ )
        {
            # must be other masks.
            next FILE;
        }
        else
        {
            push( @newnewlist, $file );
        }
    }

    @newlist = sort @newnewlist;
    print "newlist is now " . ( join ",", @newlist ) . "\n" if $verbose;
    return ( \@newlist, \@excludepatterns );
}

#
#
sub deploy
{
    my $client = $_[0];
    my $path   = $_[1];

    my $yes = 0;
    print "deploy: client: $client  path: $path\n" if $verbose;
    chdir "$stg/$client";
    print "pwd is now $stg/$client (staging area root)\n" if $verbose;
    if ($report)
    {
        &deploy_rsync( "--dry-run", $client, $path );
    }
    else
    {
        unless ($real)
        {
            &deploy_rsync( "--dry-run", $client, $path );

            # ask question.
            print "would your like run rsync now for real? [yes/No] ";
            my $answer = <STDIN>;
            if ( $answer =~ /^y/i )
            {
                $yes = 1;
            }
        }
        if ( $real || $yes )
        {
            &deploy_rsync( "", $client, $path );
        }
    }
}

#
#
sub deploy_rsync
{
    my $dryrun = $_[0];
    my $client = $_[1];
    my $path   = $_[2];
    my $output;
    my $verbose = "";

    $verbose .= " --verbose " unless ($report);

    my $command = "$rsync $rsync_opts $dryrun $verbose --itemize-changes --compress --archive --delete --recursive --links --relative";
    $command .= " --exclude-from=$excludepatternfile"
        if ( defined($excludepatternfile) );
    $command .= " .$path $client:/";

    unless ($silent)
    {
        print( $dryrun
               ? "running dry-run for " . YELLOW . ON_BLACK . "${client}:${path}" . RESET " ...\n"
               : "running rsync for real for " . GREEN . BOLD . "${client}:${path}" . RESET . " ...\n"
             );
        print( $dryrun ? BLACK ON_YELLOW BOLD: ON_GREEN BOLD );
        print $command . "\n";
        print RESET . ( $dryrun ? BLACK ON_YELLOW: ON_GREEN );
    }

    if ($report)
    {
        $reporttext .= "$client:$path";
    }

    open( RSYNC, "$command|" ) || die 'can not open $command';
    while (<RSYNC>)
    {
        if ($report)
        {
            $output .= $_;
            print $_ if ($verbose);
        }
        else
        {
            print $_;
        }
    }
    close RSYNC;
    print RESET . "\n" unless $silent;

    if ($report)
    {
        if ($output)
        {
            $unjlsyncronized++;
            $output =~ s/^/ /mg;
            $reporttext .= "\n\n" . $output . "\n";
        }
        else
        {
            $reporttext .= "  -  jlsyncronized\n";
        }
    }
}

#
# &get( $client, $path)
sub get
{
    my $client = $_[0];
    my $path   = $_[1];

    my $target;
    my $cgetmask;    # client get mask
    my $stgget        = $stg . "/" . $client . $path;
    my $srcget        = $src . $path;
    my $stggettmp     = $stg . "/" . $client . "-get";
    my $stggettmppath = $stggettmp . $path;

    # if no getmask is supplied then $client is used.
    if ( !$getmask )
    {
        $cgetmask = $client;
    }
    else
    {
        $cgetmask = $getmask;
    }

    if ( $cgetmask eq "DEFAULT" )
    {
        $target = $src . $path;
    }
    else
    {
        if ( !grep( /^\Q$cgetmask\E$/, @{ $masks_of{$client} } ) )
        {
            print BOLD . BLACK . ON_YELLOW . "WARNING client $client is currently not subscribed to mask $cgetmask\n" . RESET;
        }
        $target = $src . $path . "." . $cgetmask . ".a\~";
    }

    # now copy files from destination back into staging
    # - no could overwrite contents of hard linked files?

    my $command = "$rsync $rsync_opts --compress --itemize-changes --archive --delete --backup --backup-dir=$backup_dir --links --recursive --relative --verbose";
    $command .= " --exclude-from=$excludepatternfile"
        if ( defined($excludepatternfile) );
    $command .= " $client:$path $stggettmp";

    print "collecting remote files...\n" . BOLD . BLACK . ON_YELLOW . $command . "\n" . RESET . BLACK . ON_YELLOW;
    system $command;    # todo check return code
    print RESET . "\n";

    if ( !-e $stggettmppath )
    {
        print BOLD . RED . ON_WHITE . "Error: nothing collected from $client:$path \nplease check that remote path contains no symlinks" . RESET . "\n";
        return;
    }

    # full path search to determine repository original version...

    my $ap = '';        # accumulated path
    my $pc;             # path component
    my @pcs = split "/", $path;
    shift @pcs;         # strip leading null before /(root directory.

    my $found = 'yes';

PATHLOOP: foreach $pc (@pcs)
    {
        my $tap = $ap . '/' . $pc;

        # special code to check for basename.mask1,mask2.a~ files. grr.

        my %cfh;        # control file hash
        opendir( AP, $src . "/" . $ap ) || die "could not open $ap \! \n";
        my $nextfile;
        DIRLOOP: while ( defined( $nextfile = readdir(AP) ) )
        {
            next DIRLOOP if $nextfile !~ /^$pc/;
            print "\nnextfile is $nextfile\n" if $verbose;
            if ( $nextfile =~ /$pc\.(\w[\w\-]*(,\w[\w\-]*)?)\.([ade])\~/ )
            {
                my @masks = split( ",", $1 );
                my $type  = $3;

                foreach my $mask (@masks)
                {
                    if ( !defined( $cfh{$mask}{$type} ) )
                    {
                        print "mask $mask type $type file $nextfile\n"
                            if $verbose;
                        $cfh{$mask}{$type} = $nextfile;
                    }
                    else
                    {
                        print "ERROR duplicate control file with same mask at $cfh{$type}{$mask} AND $nextfile \n";
                        exit 0;

                    }
                }
            }
        }
        closedir(AP);

        ##
        ## BUG. all these -e tests below fail on symlinks when
        ## the symlink target does not exist on the jlsync
        ## repository machine
        ## symlinks can be the last path component
        ## the last path component
        ##
        ##

        foreach my $tmask ( reverse @{ $masks_of{$client} } )
        {
            if ( -e "${src}/${tap}.${tmask}.a~" )
            {

                # this is the path to remember
                $ap = $tap . ".${tmask}.a~";
                next PATHLOOP;
            }
            elsif ( -e "${src}/${tap}.${tmask}.d~" )
            {

                # warning/error target is current masked by ~d
                print YELLOW . ON_WHITE . "WARNING: --get target pathname is masked by control file ${src}/${tap}.${tmask}.d~" . RESET . "\n";

            }
            elsif ( -e "${src}/${tap}.${tmask}.e~" )
            {

                # warning/error target is current masked by ~e ( rsync get probably won't work )
                print YELLOW . ON_WHITE . "WARNING: --get target pathname is masked by control file ${src}/${tap}.${tmask}.e~" . "\n" . "WARNING: rsync probably won't work" . RESET . "\n";

            }
        }

        # else DEFAULT files without any mask
        if ( -e "${src}/${tap}" )
        {

            # this is the path to remember
            $ap = $tap;
        }
        else
        {
            # path not found in repository.
            $found = 'no';
            last PATHLOOP;
        }
    }

    print "Accumlated path is $ap\n" if $verbose;
    print "Was the target path found in the source repository?: $found\n"
        if $verbose;

    my $srcap = $src . $ap;

    # maybe need to add check if a directory is being replaced with a file.
    # decide what to do, then...

    # symlink up again? or use rdist?

    my $possiblesource2;
    my $possiblesource;

    if ( $found eq 'yes' )
    {
        print "current source repository ( $src ) version...\n";
        my $confirmed = '';

        if ( -f $srcap )
        {
            if ( ( stat($stgget) )[1] == ( stat("$srcap") )[1] )
            {
                $confirmed = "(confirmed)";
            }
            else
            {
                $confirmed = "(warning: source and stage inode mismatch)";
            }
        }
        my $nfiles = "";
        if ( -d $srcap )
        {
            $nfiles = `find $srcap -print | wc -l`;
            $nfiles =~ s/\D//g;
            $nfiles = "( number of files: $nfiles )";
        }
        print ON_WHITE . BLUE . "$srcap $confirmed $nfiles" . RESET . "\n";
        chdir dirname($srcap);
        print GREEN;
        system "ls", "-ld", basename($srcap);
        print RESET;
    }

    if ( -e $stgget )
    {
        print "current stage area ( $stg ) version for $client is\n";
        my $nfiles = "";
        if ( -d $stgget )
        {
            $nfiles = `find $stgget -print | wc -l`;
            $nfiles =~ s/\D//g;
            $nfiles = "( number of files: $nfiles )";
        }
        print ON_WHITE . BLUE . "$stgget $nfiles" . RESET . "\n";
        chdir dirname($stgget);
        print GREEN;
        system "ls", "-ld", basename($stgget);
        print RESET;
    }

    if ( -e $target && ( $target ne $srcap ) )
    {
        print "current repository target version is\n";
        my $nfiles = "";
        if ( -d $target )
        {
            $nfiles = `find $target -print | wc -l`;
            $nfiles =~ s/\D//g;
            $nfiles = "( number of files: $nfiles )";
        }
        print ON_WHITE . BLUE . "$target $nfiles" . RESET . "\n";
        chdir dirname($target);
        print GREEN;
        system "ls", "-ld", basename($target);
        print RESET;
    }

    print "remote ( $stggettmp ) version just got is...\n";
    my $nfiles = "";
    if ( -d $stggettmppath )
    {
        $nfiles = `find $stggettmp -print | wc -l`;
        $nfiles =~ s/\D//g;
        $nfiles = "( number of files: $nfiles )";
    }

    print ON_WHITE . BLUE . "$stggettmppath $nfiles" . RESET . "\n";
    chdir dirname($stggettmppath);
    print GREEN;
    system "ls", "-ld", basename($stggettmppath);
    print RESET;

    my $yes = 0;
    unless ($real)
    {
        print "this will be copied to...\n";
        print ON_WHITE . BLUE . $target . RESET . "\n";
        print "would your like replace files for real? [yes/No] ";
        my $answer = <STDIN>;
        if ( $answer =~ /^y/i )
        {
            $yes = 1;
        }
    }

    # TODO: it would be nice to preserve control files in any
    # subdirectories in the repository....

    # TODO: need to preserve ownership & permisions of parent directories.

    if ( $real || $yes )
    {
        print ON_GREEN . "updating " . ON_WHITE . BLUE . $target . RESET . ON_GREEN . "... ";
        print "rmtree($target)\n" if ($verbose);
        rmtree($target);
        print "mkpath" . dirname($target) . "\n" if ($verbose);
        mkpath dirname($target), 0, 0755;
        print "rename($stggettmppath, $target)\n" if ($verbose);
        rename( $stggettmppath, $target )
            || die "unable to rename $stggettmp to $target";
        print "done." . RESET . "\n";
    }

}

# spin code taken from http://dreamscape.org/code/spin - slf@dreamscape.org - steven fountain
sub spin
{
    return if $silent;

    #my @spinchars = qw(. o O o);
    my @spinchars = qw(- / | \\);
    $spinlen = @spinchars;                   # count chars to spin
    $spinpos = 0 unless defined $spinpos;    # initialize spin position
    print "\b" if $spinning;                 # backspace over the last character
    $spinning = 1 unless defined $spinning;  # is this the first run?
    print "$spinchars[$spinpos]";            # print the spin character
    $spinpos++;                              # increment the spin position
    $spinpos = 0 if ( $spinpos >= $spinlen );    # start over if no more chars
}

sub nospin
{
    return     if $silent;
    print "\b" if $spinning;                     # backspace over the last character
    undef $spinning;
    $spinpos = 0;
}

###################### MANPAGE ########################################

=head1 NAME

jlsync - rsync wrapper to deploy files from a central repository to
client hosts

=head1 SYNOPSIS

    jlsync [--real] [--nocolor] [--verbose] clienthostname:/path/to/pushout 
                [clienthostname2:/another/path2/pushout]

    jlsync --get [--real] [--mask=template_name] clienthostname:/path/to/pullin

    jlsync --report [--email=address] clienthostname:/path/to/check 
                [clienthostname2:/another/path2/check]

=head1 DESCRIPTION

jlsync is a rsync wrapper that allows files and directories to be
syncronised from a central repository to many client hosts. Files can
be grouped into file templates that individual client hosts can
"subscribe" to.  Deploy works well with ssh key authentication to avoid
rsync over ssh being prompted for remote client root passwords.

=head1 OPTIONS

--nocolor   turns of color text highlighting. By default 
rsync commands and other actions are highlighted in different colors. 

--verbose   turn on more debug output.

--get       pull files from the remote client into the repository
(instead of the default behaviour which is to push out files form the
repository).

--real      do not prompt for confirmation of actions. Use this 
option with caution!

--mask=template_name  when pulling files from a remote client put them
into the repostitory with and add mask of template_name.

--report        print out a report of differences between client
pathnames and staging image taken using the rsync --dry-run output.

--email=address	Report is emailed to the email address "address" instead of being printed out.


=head1 BASIC USAGE

To distribute /usr/java from the repository to a host called jav04
run the following commands:

First run

	 jlsync jav04:/usr/java  

this will build a staging image for jav04 and then do a rsync --dry-run of /usr/java to jav04. Look closely at the output to verify
the additions and deletions on the remote host are as expected. You
will then be prompted with "would you like run rsync now for real?
[yes/No]". Answer yes to run rsync again without the --dry-run rysnc
option (ie. go ahead and make changes to client for "real"). 

Only if you're 100% sure that jlsync is going add and delete
the correct files you can run with the --real option

	jlsync --real jav04:/usr/java

when the --real option you are not prompted and rsync to the client
does not use the --dry-run option. BE CAREFUL, incorrect usage or
incorrect configuration in the repository could easily result in the
permanent deletion of important files on the client.

=head2 Getting remote files into the repository

To quickly gather files and/or directories from a remote host back 
into the repostory the --get option can be used. 
A specific template for the gathered files can be named with the
--mask option.  For example to get a freshly installed httpd binary
back from client host web01 into the repostory for the file template
"WEBSERVERS" run

	jlsync --get --mask=WEBSERVERS web01:/usr/local/apache/bin/httpd

This will result in usr/local/apache/bin/httpd.WEBSERVERS.a~ being
added to the repostitory.  Once the file is in the repository it can be
deployed to other clients that subscribe to the WEBSERVERS template.

Files can be gathered into the special DEFAULT file template

	jlsync --get --mask=DEFAULT  holly:/usr/local/bin/rsync

will result in usr/local/bin/rsync being added to the repostitory.

When a --mask option is not given gathered files will be added to
the clients own host template.  e.g.

	jlsync --get goanna:/etc/hosts

would result in etc/hosts.goanna.a~ being added to the repository. 

=head2 The config file

Each client host has an entry in the jlsync.config file that lists the
file templates that it subscribes to. A template is made up of files
and control files in the repository that share same template/mask
name.  Using templates is a convenient way of grouping files that
should only be deployed to a certain category of hosts such as "web
servers" or "database servers".

Every client must subscribe to the base template called DEFAULT.  Also
each client also must subscribe to a template that is the same as that
client's hostname.

Templates filesets are layered one upon another to build the 
jlsync client image in the
staging area before the image is rsync'ed to the client. 
The control files for templates are applied in reverse order as they
are listed in the control file, ie. right to left. So when multiple
control files with the same basename exist the most significate control
file is used. Hostname control files are always the most significant
and the DEFAULT control files are always the least significant.

The following example jlsync.config entry shows a host, jav04, entry
that only contains the minimum of the DEFAULT template and it's own
template.

	DEFAULT	jav04

The next example jlsync.config entry shows a host, www05, who's final
file image is made up of 3 additional file templates

	DEFAULT WEBSERVERS prodservers london www05

=head2 The respository 

All the files for the all the file templates are stored in the
repostitory under the same directory root. Control files for
different templates are named with filename suffix .templatename.X~
notation. Files in the DEFAULT template don't need the suffix notation.

=head2 Control Files


=head3 the Add .templatename.a~ controlfile

Files and/or directories from the repository for a given template with
with Add control file suffix, .i<templatename>.a~ , get added to the final
staging image for clients that subscribe to i<templatename>.


=head3 the Delete .templatename.d~ controlfile

If file with the Delete control file suffix exists in the 
repository then any corresponding file or directory with the same
basename will not be added the staging image for that client.

Rsync will delete files on remote hosts that aren't found in the local
file image (that is unless they have also been excluded from the rsync
comparision).

The easiest way to create Delete and Exclude control files is to simply
"touch" them.

=head3 the Exclude .templatename.e~ controlfile

Files with Exclude suffix, .templatename.e~ , are added to the list of
files to be excluded from the rsync comparision. Any files/directories
that are excluded will not be deployed from the staging area or
updated/deleted from the client host.

The following Exclude control file will cause the /var/run/sendmail.pid
file to be be ignored (left alone) by the rsync for all client hosts

	/var/run/sendmail.pid.DEFAULT.e~

This next exclude bontrol file will cause the entire /var/mysql
directory to be ignored for any client hosts that are listed with the
"databaseservers" template in the jlsync.config file.

	/var/mysql.databaseservers.e~

Exclude control files can also contain regular expressions (as defined
and used by rsync) to match multiple files. For example, to exclude any
file ending in .pid in /app/sendSMS use

	/app/sendSMS/*.pid.DEFAULT.e~

To exclude the syslogd messages files (messages, messages.1, etc.) you
could use

	/var/log/messages*.DEFAULT.e~

To exlude all files in a directory (but make sure the directory is part
of the template) use something like

	/var/mysql/*.databaseservers.e~

=head1 ADVANCED USAGE

Multiple files from the same client can be deployed at the same time
	
	jlsync jav04:/etc/passwd jav04:/etc/shadow

this style of usage is useful when base directory of the files is not
fully syncronised with the repository. It's also quicker than two
individual invocations of jlsync as the staging image is only built
once.

Multiple clients can be deployed in a single command

	jlsync jav03:/opt/apache jav04:/opt/apache

with this sytle of usage the staging image for each client will be
built first before files are deployed.

Any combination of host:/path arguments can be used on the jlsync 
command line. e.g.

	jlsync db01:/u01 nfs1:/export anyhost:/any/path

=head2 Advanced Control Files

A control file can belong to multiple masks at once by separating the
masks with a comma "," e.g.

	/opt/apache.www3,www4.a~
and
	/etc/motd.INTERNAL,EXTERNAL,DMZ.e~

=head2 Advanced command line with multiple hosts

When the same path needs to be jlsynced to multiple hosts those hosts 
can given as a single comma separated list prior to the path. e.g.

	jlsync sol01,sol02,sol03,sol04,sol05,sol06,sol07:/opt/csw

=head2 Advanced command line with matching template/mask names

The =templatename:/path notation can be used to match all hosts that 
"subscribe" to that templatename in the jlsync.config file. For example 
to select all hosts that have the SOLARIS template listed in as part 
configuration in jlsync.config the following could be used.

	jlsync =SOLARIS:/etc/nscd.conf

And because all hosts must subscribe to the DEFAULT template the 
following will jlsync to all configured hosts

	jlsync =DEFAULT:/etc/issue

It's possible to get the intersection of muliple templates by chaining them 
together. For example the following would match all production debian hosts in newyork

	jlsync =PROD=DEBIAN=newyork:/usr/local/etc/timezone

To get the union of multiple templates you can separate them by commas. 
e.g. All hosts in London and Melbourne
	
	jlsync =LONDON,=MELBOURNE:/etc/passwd =LONDON,=MELBOURNE:/etc/shadow

=head1 REPORT OPTION

Ad-hoc filesystem changes made on a client can cause it's configuration
to "drift" away from it's jlsync repository configuration. The --report
option can help maintain discipline over client and jlsync repository
changes by reporting any differences found. e.g.

	jlsync --report bill:/usr/local ben:/usr/local

will generate an onscreen report of changes between the /usr/local
directors on clients bill and ben and the repository. Using the --email
option will cause the report to be sent via email e.g.

	jlsync --report --email=admin@company.com mailhub:/etc/mail

Scheduling jlsync reports in cron can be a useful way to keep an eye on
client/repository drift.


=head1 TODO

lots.

=head1 BUGS

many.
--get'ting a symlink

=head1 SEE ALSO

the rsync(1) man page.

=head1 AUTHOR

Jason Lee

=cut

