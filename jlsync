#!/usr/bin/perl -w

# deploy - not yet useable
#
# Jason Lee, deploy@jason-lee.net.au, March 2002
#
# $Id: jlsync,v 1.4 2002/03/18 02:37:43 plastic Exp $

use strict;
use File::Find ();
use File::Path;
use File::Basename;
use Getopt::Long;


# for the convenience of &wanted calls, including -eval statements:
use vars qw/*name *dir *prune $mask @excludepatterns @masks/;
*name   = *File::Find::name;
*dir    = *File::Find::dir;
*prune  = *File::Find::prune;

# directories without trailing /
my $deploydir = "/var/tmp/deploy";
my $src = $deploydir . "/src";
my $stg = $deploydir . "/stg";
my $dst = $deploydir . "/dst";

my $backup_dir = "/var/tmp/deploy/backup_dir";

$| = 1; # turn on autoflush

my $real = '';  
my $get = '';  
my $getmask = '';  
GetOptions( "real" =>\$real , 	# --real
	    "get" =>\$get ,     # --get
	    "mask=s" =>\$getmask ,# --mask
		);

my $dryrun =  $real ? "" : "--dry-run";

my $excludepatternfile = "/tmp/" . "spit" . time . $$;
my ( $client, $path ) = split (":",$ARGV[0]);
$path = "/" unless ($path); 
$path =~ s|^|/| unless ( $path =~ m|^/| ); 

my @masks;

&buildstage($client);

if ( $get )
{
	&get()
}
else
{
	&deploy();
}


#unlink $excludepatternfile;
exit 0;

sub buildstage
{
	my $client = $_[0];
	# check for any mask dependices
	open(MASK,"deploy.config");
	while(<MASK>)
	{
		s/\s+$//;
		my @tmasks = split (/\s+/);
		if ($tmasks[0] eq 'DEFAULT' && $tmasks[$#tmasks] eq $client )
		{
			@masks = @tmasks[0..($#tmasks -1 )];
			last;
		}
	}
	close MASK;
	push @masks,$client;

	print "masks are " . join(" ",@masks) . "\n";

	@excludepatterns = ( "*.~" , "*.d~", "*.i~" );

	# first copy files to staging area
	my $command;
	$command = "rsync --compress --archive --delete --recursive --links --rsh=ssh  --relative $src$path $stg/";
	print "running $command\n"; 
	system $command;

	# Traverse desired filesystem (loop by mask or function first?)
	#my $mask;
	foreach $mask (@masks)
	{
		chdir $stg; # keep it relative
		File::Find::find({wanted => \&delete, no_chdir => 1}, "." );
		File::Find::find({wanted => \&add, no_chdir => 1}, "." );
		File::Find::find({wanted => \&ignore, no_chdir => 1}, "." );
	}


	print "ignored files are:\n" . join ("\n",@excludepatterns) . "\n";
	open(TMP,">$excludepatternfile");
	print TMP join ("\n",@excludepatterns) . "\n";
	close TMP;
}

sub deploy
{
	# now copy files from stage to destination
	my $command = "rsync $dryrun --verbose --compress --archive --delete --recursive --links --rsh=ssh --exclude-from=$excludepatternfile  $stg$path $client:$path";
	print "running $command\n";
	system $command;
}

sub delete {
		if ( $name =~ /^(.*)\.${mask}\.d~\z/s )
		{
			my $target = $1;
			print "removing $target";
			rmtree($target); 
		}
}

sub add {
	if ( $name =~ /^(.*)\.${mask}\.~\z/s )
	{
		my $target = $1;
		if ( -e $target )
		{
			print "removing $target\n";
			rmtree( $target ); 
		}
		print "renaming $name to $target\n";
		rename  $name , $target;
	}
}

sub ignore {
	if (  $name =~ /^(.*)\.${mask}\.i~\z/s )
	{
		my $target = $1;
		(my $targetpathname =  $target ) =~ s|^\.|| ;
		print("excluding $targetpathname\n");
		push (@excludepatterns, $targetpathname);
	}
}


sub get
{
	my $get = $path;
	my $target;
	my $stgget = $stg . $get;
	my $srcget = $src . $get;

        # if no getmask is supplied then DEFAULT is used if the files
        # don't already exist in the repostor with DEFAULT mask, or if
        # they do exist then the client's own mask is used.
	if ( ! $getmask )
	{
		if ( -e $srcget )
		{
			$getmask = $client;
		}
		else
		{
			$getmask = "DEFAULT";
		}
	}
	
	if ( $getmask eq "DEFAULT" )
	{
		$target = $src . $get;
	}
	else
	{
		$target = $src . $get . "." . $getmask . ".\~";
	}

	# now copy files from destination back into staging 

	print "rsync --compress --archive --rsh=ssh --exclude-from=$excludepatternfile --delete   --backup --backup-dir=$backup_dir --links --recursive --relative --verbose $client:$get $stg \n";
	open(RSYNC, "rsync --compress --archive --rsh=ssh --exclude-from=$excludepatternfile --delete --backup --backup-dir=$backup_dir --links --recursive --relative --verbose $client:$get $stg |") ;
	my @changes = (<RSYNC>);
	close RSYNC;
	
	print "changes are:\n",@changes,"\n";


	# maybe need to add check if a directory is being replaced with a file.

	# rsync up...

	my $s = "$stg$get";
	if ( -d  $s )
	{
		$s =~ s|$|/| ;
		system "mkdir","-p",$target;
	}
	else
	{
		system "mkdir","-p",basename($target);
	}

	my $command;
	$command = "rsync --compress --archive --delete --exclude-from=$excludepatternfile --recursive --links --rsh=ssh  $s $target";
	print "running $command\n"; 
	system $command;

	# now check for i~ or d~ obscructions
	my $base = $src . $get ;
	if ( $getmask ne "DEFAULT" )
	{
		$base .=  "." . $getmask ;
	}
		
	my $ex;
	foreach  $ex ( ".i~", ".d~" )
	{
		my $baseex = $base . $ex;
		if ( -e $baseex )
		{
			print "deleteing  $baseex\n";
			rmtree ($baseex);
		}
	}
}

