#!/usr/local/bin/perl -w

# jlsync - not yet useable
#
# Jason Lee, jlsync@jason-lee.net.au, March 2002
#
# Copyright © 2002-2004 Jason Lee
#
# $Id: jlsync,v 1.35 2005/04/29 13:58:21 plastic Exp $

=head1 NAME

jlsync - rsync wrapper to deploy files from a central repository to
client hosts

=head1 SYNOPSIS

    jlsync [--real] [--nocolor] [--verbose] clienthostname:/path/to/pushout [clienthostname2:/another/path2/pushout]

    jlsync --get [--real] [--mask=template_name] clienthostname:/path/to/pullin

    jlsync --report [--email=address] clienthostname:/path/to/check [clienthostname2:/another/path2/check]

=head1 DESCRIPTION

jlsync is a rsync wrapper that allows files and directories to be
syncronised from a central repository to many client hosts. Files can
be grouped into file templates that individual client hosts can
"subscribe" to.  Deploy works well with ssh key authentication to avoid
rsync over ssh being prompted for remote client root passwords.

=head1 OPTIONS

--nocolor   turns of color text highlighting. By default 
rsync commands and other actions are highlighted in different colors. 

--verbose   turn on more debug output.

--get       pull files from the remote client into the repository
(instead of the default behaviour which is to push out files form the
repository).

--real      do not prompt for confirmation of actions. Use this 
option with caution!

--mask=template_name  when pulling files from a remote client put them
into the repostitory with and add mask of template_name.

--report        print out a report of differences between client
pathnames and staging image taken using the rsync --dry-run output.

--email=address	Report is emailed to the email address "address" instead of being printed out.


=head1 BASIC USAGE

To distribute /usr/java from the repository to a host called jav04
run the following commands:

First run

	 jlsync jav04:/usr/java  

this will build a staging image for jav04 and then do a rsync --dry-run of /usr/java to jav04. Look closely at the output to verify
the additions and deletions on the remote host are as expected. You
will then be prompted with "would you like run rsync now for real?
[yes/No]". Answer yes to run rsync again without the --dry-run rysnc
option (ie. go ahead and make changes to client for "real"). 

Only if you're 100% sure that jlsync is going add and delete
the correct files you can run with the --real option

	jlsync --real jav04:/usr/java

when the --real option you are not prompted and rsync to the client
does not use the --dry-run option. BE CAREFUL, incorrect usage or
incorrect configuration in the repository could easily result in the
permanent deletion of important files on the client.

To quickly gather files from a remote host back into the repostory the
--get option can be used. By default gathered files will be added to
the client host template.  A specific template can be named with the
--mask option.  For example to get a freshly installed httpd binary
back from client host web01 into the repostory for the file template
"WEBSERVERS" run

	deloy --get --mask=WEBSERVERS web01:/usr/local/apache/bin/httpd

This will result in usr/local/apache/bin/httpd.WEBSERVERS.a~ being
added to the repostitory.  Once the file is in the repository it can be
deployed to other clients that subscribe to the WEBSERVERS template.

=head2 The config file

Each client host has an entry in the jlsync.config file that lists the
file templates that it subscribes to. A template is made up of files
and control files in the repository that share same template/mask
name.  Using templates is a convenient way of grouping files that
should only be deployed to a certain category of hosts such as "web
servers" or "database servers".

Every client must subscribe to the base template called DEFAULT.  Also
each client also must subscribe to a template that is the same as that
client's hostname.

Templates filesets are layered one upon another to build the 
jlsync client image in the
staging area before the image is rsync'ed to the client. 
The control files for templates are applied in reverse order as they
are listed in the control file, ie. right to left. So when multiple
control files with the same basename exist the most significate control
file is used. Hostname control files are always the most significant
and the DEFAULT control files are always the least significant.

The following example jlsync.config entry shows a host, jav04, entry
that only contains the minimum of the DEFAULT template and it's own
template.

	DEFAULT	jav04

The next example jlsync.config entry shows a host, www05, who's final
file image is made up of 3 additional file templates

	DEFAULT WEBSERVERS prodservers london www05

=head2 The respository 

All the files for the all the file templates are stored in the
repostitory under the same directory root. Control files for
different templates are named with filename suffix .templatename.X~
notation. Files in the DEFAULT template don't need the suffix notation.

=head2 Control Files


=head3 the Add .templatename.a~ controlfile

Files and/or directories from the repository for a given template with
with Add control file suffix, .i<templatename>.a~ , get added to the final
staging image for clients that subscribe to i<templatename>.


=head3 the Delete .templatename.d~ controlfile

If file with the Delete control file suffix exists in the 
repository then any corresponding file or directory with the same
basename will not be added the staging image for that client.

Rsync will delete files on remote hosts that aren't found in the local
file image (that is unless they have also been excluded from the rsync
comparision).

The easiest way to create Delete and Exclude control files is to simply
"touch" them.

=head3 the Exclude .templatename.e~ controlfile

Files with Exclude suffix, .templatename.e~ , are added to the list of
files to be excluded from the rsync comparision. Any files/directories
that are excluded will not be deployed from the staging area or
updated/deleted from the client host.

The following Exclude control file will cause the /var/run/sendmail.pid
file to be be ignored (left alone) by the rsync for all client hosts

	/var/run/sendmail.pid.DEFAULT.e~

This next exclude bontrol file will cause the entire /var/mysql
directory to be ignored for any client hosts that are listed with the
"databaseservers" template in the jlsync.config file.

	/var/mysql.databaseservers.e~

Exclude control files can also contain regular expressions (as defined
and used by rsync) to match multiple files. For example, to exclude any
file ending in .pid in /app/sendSMS use

	/app/sendSMS/*.pid.DEFAULT.e~

To exclude the syslogd messages files (messages, messages.1, etc.) you
could use

	/var/log/messages*.DEFAULT.e~

To exlude all files in a directory (but make sure the directory is part
of the template) use something like

	/var/mysql/*.databaseservers.e~

=head1 ADVANCED USAGE

Multiple files from the same client can be deployed at the same time
	
	jlsync jav04:/etc/passwd jav04:/etc/shadow

this style of usage is useful when base directory of the files is not
fully syncronised with the repository. It's also quicker than two
individual invocations of jlsync as the staging image is only built
once.

Multiple clients can be deployed in a single command

	jlsync jav03:/opt/apache jav04:/opt/apache

with this sytle of usage the staging image for each client will be
built first before files are deployed.

=head2 Advanced Control Files

A control file can belong to multiple masks at once by separating the
masks with a comma "," e.g.

	/opt/apache.www3,www4.a~
and
	/etc/motd.INTERNAL,EXTERNAL,DMZ.e~


=head1 REPORT OPTION

Ad-hoc filesystem changes made on a client can cause it's configuration
to "drift" away from it's jlsync repository configuration. The --report
option can help maintain discipline over client and jlsync repository
changes by reporting any differences found. e.g.

	jlsync --report bill:/usr/local  ben:/usr/local

will generate an onscreen report of changes between the /usr/local
directors on clients bill and ben and the repository. Using the --email
option will cause the report to be sent via email e.g.

	jlsync --report --email=admin@company.com mailhub:/etc/mail

Scheduling jlsync reports in cron can be a useful way to keep an eye on
client/repository drift.


=head1 TODO

	pre and post exec command control files?
	log files?
	friendly remote diff/cmp ?
	pager
	use File::Same
	use more rysnc options. --update ?  --backup ?

=head1 BUGS

	--get ting a symlink

=head1 SEE ALSO

the rsync(1) man page.

=head1 AUTHOR

Jason Lee

=cut



use strict;
use Cwd;
use File::Find ();	  	# recent version required.
use File::Path;
# use File::stat;		# TODO: maybe use this later.
use Term::ANSIColor qw(:constants);
use File::Basename;
use Getopt::Long;
use Mail::Mailer;


# for the convenience of &wanted calls, including -eval statements:
use vars qw/*name *dir *prune $mask @excludepatterns @masks/;
*name   = *File::Find::name;
*dir    = *File::Find::dir;
*prune  = *File::Find::prune;

# config file
my $config="/jlsync/jlsync.config";

# path to rsync version 2.6.0 
my $rsync="/usr/local/bin/rsync";

# special command line options to always use with rsync
my $rsync_opts = "--rsync-path=/usr/local/bin/rsync --rsh=/usr/local/bin/ssh";

# directories without trailing /
my $jlsyncdir = "/jlsync";
my $src = $jlsyncdir . "/source";
my $stg = $jlsyncdir . "/stage";
my $backup_dir = $jlsyncdir . "/backup";

my $abletolinktosymlinks = 0 ; # linux = 1 , solaris = 0 ;

my $smtpserver = '127.0.0.1';
my $reportfrom = 'jlsync Report <root>';

my @controlfiles = (); # array of control file hashes.

$| = 1; # turn on autoflush

my $spinpos;
my $spinning;
my $spinlen;

umask 0 ; # needed by subsequent mkdirs

my %cph ;  # Client Path Hash

my $client;
my $path;
my $verbose;  
my $report;  
my $email;  
my $silent;  
my $reporttext ;  
my $real;  
my $get;  
my $getmask;  
my $nocolor;  
my $unjlsyncronized = 0;

GetOptions( "real" =>\$real , 			# --real
	    "get" =>\$get ,     		# --get
	    "verbose" =>\$verbose ,     	# --verbose
	    "report" =>\$report ,       	# --report
	    "email=s" =>\$email ,       	# --email=address
	    "nocolor|nocolour" =>\$nocolor ,    # --nocolor
	    "mask=s" =>\$getmask ,		# --mask=MASKNAME
	    "silent" =>\$silent ,     # --silent available on commandline for testing
	);

	
&usage unless (defined $ARGV[0]);

foreach my $arg (@ARGV)
{
	&usage unless ($arg =~ m|\w[\w-]*:/|);
}


if ( ( $real && $report) || ( $get && $report ) || ( $real && $email) || ( $get && $email ) )
{
	&usage;
}

$silent = 1 if $report;

foreach my $arg (@ARGV)
{
	$arg =~ m|(.+):(.+)|;
	my $client = $1;
	my $path = $2;
	push(@{$cph{$client}->{paths}},$path);
}


my $dryrun =  $real ? "" : "--dry-run";
$ENV{'ANSI_COLORS_DISABLED'} = 'nocolor' if ( $nocolor ) ;

my $excludepatternfile;

my %maskshash;
my @masks;
open(MASK, $config) || die "can not open $config";
while(<MASK>)
{
	next if /^#/;
	s/\s+$//;
	my @tmasks = split (/\s+/);
	if ($tmasks[0] eq 'DEFAULT' )
	{
		if ( defined $maskshash{$tmasks[$#tmasks]} )
		{
			print BOLD . RED . "Error: duplicate entires for $tmasks[$#tmasks] is file $config . exiting." . RESET . "\n";
			exit 1;
		}
		else
		{
			$maskshash{$tmasks[$#tmasks]} = \@tmasks;
		}
	}
}
close MASK;

foreach $client (keys %cph)
{
	unless (defined $maskshash{$client}) 
	{
		print "$client not found in file $config. exiting.\n";
		exit 1;
	}
}

foreach $client (keys %cph)
{
	my $lockfile = "$stg/${client}-lock";
	if ( -f $lockfile )
	{
		print "jlsync currently locked ( $lockfile ) by process id ";
		system "cat",$lockfile;
		print "\n";
		exit 1;
	}
}
foreach $client (keys %cph)
{
	my $lockfile = "$stg/${client}-lock";
	open(LOCK,">$lockfile") || die "could not create lockfile: $lockfile";
	print LOCK $$;
	close LOCK;
}



foreach $client (keys %cph)
{
	@excludepatterns = ();
	&buildstage($client);
	@{$cph{$client}->{excludepatterns}} = @excludepatterns;
}

foreach $client (keys %cph)
{
	print "exclude patterns for "  . RED . BOLD . $client . RESET.  " are:\n" . ON_CYAN . "\n"  . join ("\n",@{$cph{$client}->{excludepatterns}}) . "\n" . RESET . "\n" unless $silent;

	@excludepatterns = @{$cph{$client}->{excludepatterns}} ;

	$excludepatternfile = "/tmp/" . ".jlsync-" . $client ."-". time ."-". $$;

	open(TMP,">$excludepatternfile") || die "could not open $excludepatternfile";
	print TMP join ("\n",@excludepatterns) . "\n";
	close TMP;

	foreach $path ( @{$cph{$client}->{paths}} )
	{
		if ( $get )
		{
			&get($client, $path)
		}
		else
		{
			&deploy($client, $path);
		}
	}

	unlink $excludepatternfile;
}


foreach $client (keys %cph)
{
	my $lockfile = "$stg/${client}-lock";
	unlink $lockfile;
}

if ( $report)
{
	my $rl = <<END;
rsync --itemize legend: UXcstpoga
action U: <)send  >)receive  c)change/create  h)hardlink  .)attribute chanage
file-types X: f)file  d)directory  L)symlink  D)device
why: c)hecksum s)ize t)imestamp p)ermissions o)wner g)roup a)extended attribute
END

	$reporttext = "jlsync report at " . localtime(time) .  "\n\n" .
	 ( $unjlsyncronized > 0 ? $rl . "\n\n" : "" ) .
	 $reporttext . 
	 "\nend of report.\n";

	if ( $email )
	{
		my $sinfo = ( $unjlsyncronized > 0 ) ? 
			" - out of sync: " . $unjlsyncronized	
			:
			" - fully jlsyncronized";
		
		my $mailer = Mail::Mailer->new('smtp', Server => $smtpserver);
		$mailer->open({ From => $reportfrom ,
		To => $email ,
		Subject => 'jlsync report at ' . localtime(time) . $sinfo } );
		print $mailer $reporttext;
		$mailer->close();
	}
	else
	{
		print $reporttext;
	}
}

exit 0;

######################################################



sub usage
{
	print "jlsync usage:\n";
	print "jlsync [--real] [--nocolor] [--verbose ] client:/path/to/pushout [more:/client/path/pairs]\n";
	print "jlsync --get [--mask=MASK] [--real] [--nocolor] [--verbose ] client:/path/to/pullback\n";
	exit 1;
}

sub buildstage
{
	$client = $_[0];
	@masks = @{$maskshash{$client}}; # @masks is a global var

	print "masks are ".RED.BOLD.join(" ",@{$maskshash{$client}}) .RESET.".\n" unless $silent; 

	print "buildstage: client: $client  masks: " . join(',',@masks) . "\n" if $verbose;

	print "deleting old image for $client in $stg/$client ... " unless $silent;
	system "/bin/rm -rf $stg/$client"; if ( $? !=0 ) {  die "could not /bin/rm -rf $stg/$client"; }
	print "done.\n" unless $silent;

	chdir $src;
	print "pwd is now $src (repository area root)\n" if $verbose;

	mkdir "$stg/$client", 0755 or die "could not mkdir $stg/$client";
	print "building new image for $client in $stg/$client ... " unless $silent;

	# link files to staging area
	File::Find::find({ 
			preprocess => \&filtercontrolfiles, 
			wanted => \&hardlinkfiles, 
			postprocess => \&setdirdate, 
			no_chdir => 1
				}, "." );
	nospin();

	print "done.\n" unless $silent;

	s|^\.|| foreach @excludepatterns;

}

sub filtercontrolfiles {
	my @filelist = @_;
	my @newlist = sort @filelist ;
	if ($verbose)
	{
		print "predir is $dir\n" ;
		print "newlist is " . (join ",",@newlist) . "\n" ;
	}
	else
	{
		spin();
	}	

	foreach $mask (reverse @masks)
	{
		my @alist = grep  /\.(\w[\w-]*,)*$mask(,\w[\w-]*)*\.a~$/  , @newlist;
		my $a;
		foreach $a (@alist)
		{
			print "a~ is $a\n" if $verbose;
			(my $basename = $a) =~ s/\.(\w[\w-]*,)*$mask(,\w[\w-]*)*\.a~$//;
			@newlist = grep !/^\Q$basename\E$/,@newlist;
			@newlist = grep !/^\Q$basename\E\.\w[\w-]*(,\w[\w-]*)*\.[ade]\~$/,@newlist;
			push (@newlist,$a);
		}

		my @dlist = grep  /\.(\w[\w-]*,)*$mask(,\w[\w-]*)*\.d~$/  , @newlist;
		my $d;
		foreach $d (@dlist)
		{
			print "d~ is $d\n" if $verbose;
			(my $basename = $d) =~ s/\.(\w[\w-]*,)*$mask(,\w[\w-]*)*\.d~$//;
			@newlist = grep !/^\Q$basename\E$/,@newlist;
			@newlist = grep !/^\Q$basename\E\.\w[\w-]*(,\w[\w-]*)*\.[ade]\~$/,@newlist;
		}

		my @elist = grep  /\.(\w[\w-]*,)*$mask(,\w[\w-]*)*\.e~$/  , @newlist;
		my $e;
		foreach $e (@elist)
		{
			print "e~ is $e\n" if $verbose;
			(my $basename = $e) =~ s/\.(\w[\w-]*,)*$mask(,\w[\w-]*)*\.e~$//;
			@newlist = grep !/^\Q$basename\E$/,@newlist;
			@newlist = grep !/^\Q$basename\E\.\w[\w-]*(,\w[\w-]*)*\.[ade]\~$/,@newlist;
			push (@excludepatterns, $dir ."/". $basename);
		}
	}

        # strip out any remaining control files for other non-matched while preserving .a~ files.
        my $f;
        my @newnewlist = ();
        foreach $f (@newlist)
        {
                if ( $f =~ /\.(\w[\w\-\,]*)\.a\~$/ )        # need to fix this to properly identifiy .MASK1,MASK2,MASK3.a~ and $1 $2 $3 etc.
                {
                        my @ms = split(",",$1);
			foreach my $m (@ms)
			{
				if ( grep /^$m$/, @masks )
				{
                        		push(@newnewlist, $f);
					last;
				}
			}
                }
                elsif ( $f =~ /\.[ed]\~$/ )
                {
                        # must be other masks.
                        next;
                }
                else
                {
                        push(@newnewlist, $f);
                }
        }
	@newlist = sort @newnewlist;

	print "newlist is now " . (join ",",@newlist) . "\n" if $verbose;
	return @newlist;
}

sub hardlinkfiles {

	(my $tname = $name) =~ s|^./||;
	my $tbasename = $tname;
	
	if  ( $tbasename =~ m|(.*)\.\w[\w\-\,]*\.a\~$|  )
	{
		$tbasename = $1;
	}

	lstat $name ; # need lstat not stat to correctly identify symlinks

	if ( -f _ )
	{
		print "$name is a file\n" if $verbose;
		link("$src/$tname","$stg/$client/$tbasename") || die "unable to link $src/$tname to $stg/$client/$tbasename";
	}
	elsif ( -d _ ) # -d on symlink to a dir will succeed on linux/ext2fs
	{
		print "$name is a dir\n" if $verbose;
		my ( $mode, $uid, $gid ) = (stat(_))[2,4,5];
		$mode = $mode & 07777; # mask off file type
		mkdir "$stg/$client/$tname", $mode || die "unable to mkdir $stg/$client/$tname";
		chown $uid, $gid, "$stg/$client/$tname";
	}
	elsif ( -l _ )
	{
		# Need some special code here to handle copying or 
		# hardlink of relative symlinks

		print "$name is a symlink\n" if $verbose;
		if ( $abletolinktosymlinks )
		{
			link("$src/$tname","$stg/$client/$tbasename") || die "unable to link $src/$tname to $stg/$client/$tbasename";
		}
		else
		{
			# deference symlink
			my $target = readlink;
			# create new symlink like original
			symlink( $target , "$stg/$client/$tbasename") || die "unable to symlink $target to $stg/$client/$tbasename";
			# set timestamp - this doesn't work sets time stamp on target of link not symlink itself. rsync seems to be ignoring symlink timestamps anyway.
			# utime(time, (lstat($name))[9], "$stg/$client/$tbasename");
		}
	}
	else
	{
		print "not a file, symlink or directory: $name\n";
	}
}

sub setdirdate {
	(my $tdir = $dir) =~ s|^./||;
	my $tbasedir = $tdir;
	if  ( $tbasedir =~ m|(.*)\.\w[\w-]*\.a\~$|  )
	{
		$tbasedir = $1;
		rename "$stg/$client/$tdir","$stg/$client/$tbasedir";
	}
	utime(time, (stat($dir))[9], "$stg/$client/$tbasedir");
}

sub getcontrolfiles {
	if ( $name =~ /^(.*)\.(\w[\w-]*).([dae])~\z/s )
	{
		my $target = $1;
		my $mask = $2;
		my $controltype = $3;
		push(@controlfiles, { "name" => $name, "target" => $target, "mask" => $mask, "controltype" => $controltype } );
	}
}

#
#
sub deploy
{
	my $client = $_[0];
	my $path = $_[1];

	my $yes = 0;
	print "deploy: client: $client  path: $path\n" if $verbose;
	chdir "$stg/$client";
	print "pwd is now $stg/$client (staging area root)\n" if $verbose;
	if ( $report )
	{
		&report_rsync($client,$path);
	}
	else
	{
		unless ( $real )
		{
			&deploy_rsync("--dry-run",$client,$path);

			# ask question.
			print "would your like run rsync now for real? [yes/No] ";
			my $answer = <STDIN>;
			if ( $answer =~ /^y/i )
			{
				$yes = 1;	
			}
		}
		if ( $real || $yes )
		{
			&deploy_rsync("",$client,$path);
		}
	}
}

# maybe fold this back into deploy_rsync at some stage.
#
sub report_rsync
{
	my $client = $_[0];
	my $path = $_[1];
	my $output;

	my $command = "$rsync $rsync_opts --dry-run --itemize-changes --compress --archive --delete --recursive --links --relative --exclude-from=$excludepatternfile  .$path $client:/";

	$reporttext .= "$client:$path";

	open (RSYNC, "$command|") || die 'can not open $command';
	while (<RSYNC>)
	{
			$output .= $_;
			print $_ if ($verbose);
	}
	close RSYNC;

	if ($output)
	{
		$unjlsyncronized++;
		$reporttext .= "\n\n" . $output . "\n";
	}
	else
	{
		$reporttext .= "  -  jlsyncronized\n";
	}
}

sub deploy_rsync
{
	my $dryrun = $_[0];
	my $client = $_[1];
	my $path = $_[2];

	my $command = "$rsync $rsync_opts $dryrun --itemize-changes --verbose --compress --archive --delete --recursive --links --relative --exclude-from=$excludepatternfile  .$path $client:/";

	unless ($silent)
	{
		print ($dryrun ? "running dry-run first for ${client}:${path} ...\n" : "running rsync for real for ${client}:${path} ...\n") ;
		print ($dryrun ? ON_YELLOW BOLD : ON_GREEN BOLD) ;
		print $command . "\n" ;
		print RESET . ($dryrun ? ON_YELLOW : ON_GREEN );
	}
	#system $command;
	open (RSYNC, "$command|") || die 'can not open $command';
	while (<RSYNC>)
	{
		if ( $report )
		{
			$reporttext .= $_;
		}
		else
		{
			print $_;
		}
	}
	close RSYNC;
	print RESET ."\n" unless $silent;
}

sub delete 
{
	my $name = $_[0];
	if ( $name =~ /^(.*)\.${mask}\.d~\z/s )
	{
		my $target = $1;
		print "removing $target\n";
		rmtree($target); 
	}
}

sub add {
	my $name = $_[0];
	if ( $name =~ /^(.*)\.${mask}\.a~\z/s )
	{
		my $target = $1;
		if ( -e $target )
		{
			print "removing $target\n";
			rmtree( $target ); 
		}
		print "renaming $name to $target\n";
		rename  $name , $target;
	}
}

sub exclude {
	my $name = $_[0];
	if (  $name =~ /^(.*)\.${mask}\.e~\z/s )
	{
		my $target = $1;
		(my $targetpathname =  $target ) =~ s|^\.|| ;
		print "excluding $targetpathname\n";
		push (@excludepatterns, $targetpathname);
	}
}


#
# &get( $client, $path)
sub get
{
	my $client = $_[0];
	my $path   = $_[1];

	my $target;
	my $cgetmask; # client get mask
	my $stgget = $stg . "/" . $client . $path;
	my $srcget = $src . $path;
	my $stggettmp = $stg . "/" . $client . "-get";
	my $stggettmppath = $stggettmp  . $path ;

        # if no getmask is supplied then $client is used.
	if ( ! $getmask )
	{
		$cgetmask = $client;
	}
	else
	{
		$cgetmask = $getmask;
	}
	
	if ( $cgetmask eq "DEFAULT" )
	{
		$target = $src . $path;
	}
	else
	{
		if ( ! grep(/^\Q$cgetmask\E$/, @{$maskshash{$client}}) )
		{
			print BOLD.YELLOW . "WARNING client $client is currently not subscribed to mask $cgetmask\n". RESET;
		}
		$target = $src . $path . "." . $cgetmask . ".a\~";
	}

	# now copy files from destination back into staging 
	# - no could overwrite contents of hard linked files?

	my $command = "$rsync $rsync_opts --compress --archive --exclude-from=$excludepatternfile --delete --backup --backup-dir=$backup_dir --links --recursive --relative --verbose $client:$path $stggettmp \n";

	print "collecting remote files...\n".BOLD.ON_YELLOW . $command ."\n". RESET . ON_YELLOW;
	system $command;
	print RESET . "\n";

	# maybe need to add check if a directory is being replaced with a file.
	# decide what to do, then...

	# symlink up again? or use rdist?

	my $possiblesource2;
	my $possiblesource;

	if ( -e $stgget )
	{
		print "current image version for $client is\n";
		print BLUE . "$stgget\n" . RESET ;
		chdir dirname($stgget);
		print GREEN;
		system "ls","-ld", basename($stgget);
		print RESET;
		if ( -d $stgget ) 
		{
			print "number of files: ";
			system "find $stgget -print | wc -l";
		}
		print "taken from repository version...\n";
		my $confirmed;

		# this code needs to be updated (does not find files in masked parent directories or files with multiple masks)
		# best solution is to use find and look for common inode.
		#
		foreach $possiblesource (  ( map $srcget . "." . $_ . ".a~", reverse @{$maskshash{$client}}), $srcget) 
		{
			if ( -e $possiblesource )
			{
				if ( -f $possiblesource )
				{
					if ( (stat($stgget))[1] == (stat($possiblesource))[1] )
					{
						$confirmed = "confirmed";
					}
					else
					{
						$confirmed = "warning: inter-directory control file conflict exists";
					}
				}
				else
				{
					$confirmed = "not confirmed";
				}
				$possiblesource2 = $possiblesource;
				last;
			}
		}
		print BLUE . "$possiblesource2 ($confirmed)\n" . RESET ;
		chdir dirname($possiblesource2);
		print GREEN;
		system "ls","-ld", basename($possiblesource2);
		print RESET;
		if ( -d $possiblesource2 ) 
		{
			print "number of files: ";
			system "find $possiblesource2 -print | wc -l";
		}
	}
	if ( -e $target  && ( $target ne $possiblesource2 ) )
	{
		print "current repository target version is\n";
		print  BLUE . "$target\n" . RESET ;
		chdir dirname($target);
		print GREEN;
		system "ls","-ld",basename($target);
		print RESET;
		if ( -d $target ) 
		{
			print "number of files: ";
			system "find $target -print | wc -l";
		}
	}
	
	print "remote version just got is...\n" . BLUE . "$stggettmppath\n" . RESET;
	chdir dirname($stggettmppath);
	print GREEN;
	system "ls","-ld",basename($stggettmppath);
	print RESET;
	if ( -d $stggettmppath ) 
	{
		print "number of files: ";
		system "find $stggettmp -print | wc -l";
	}

	my $yes = 0;
	unless ( $real )
	{
		print "this will be copied to...\n";
		print BLUE;
		print "$target\n";
		print RESET;
		print "would your like replace files for real? [yes/No] ";
		my $answer = <STDIN>;
		if ( $answer =~ /^y/i )
		{
			$yes = 1;
		}
	}

	# TODO: it would be nice to preserve control files in any 
	# subdirectories in the repository....

	# TODO: need to preserve ownership & permisions of parent directories.

	if ( $real || $yes )
	{
		print ON_GREEN . "updating " . BLUE . $target . RESET . ON_GREEN . "... ";
		print "rmtree($target)\n" if ($verbose);
		rmtree($target); 
		print "mkpath" . dirname($target) . "\n" if ($verbose);
		mkpath dirname($target), 0, 0755;
		print "rename($stggettmppath, $target)\n" if ($verbose);
		rename($stggettmppath, $target) || die "unable to rename $stggettmp to $target";
		print "done." . RESET . "\n";
	}


}



# spin code taken from http://dreamscape.org/code/spin - slf@dreamscape.org - steven fountain
sub spin
{
	return if $silent;
	#my @spinchars = qw(. o O o);
	my @spinchars = qw(- / | \\);
	$spinlen = @spinchars; # count chars to spin
	$spinpos = 0 unless defined $spinpos; # initialize spin position
	print "\b" if $spinning; # backspace over the last character
	$spinning = 1 unless defined $spinning; # is this the first run?
	print "$spinchars[$spinpos]"; # print the spin character
	$spinpos++; # increment the spin position
	$spinpos = 0 if ($spinpos >= $spinlen); # start over if no more chars
}

sub nospin
{
	return if $silent;
	print "\b" if $spinning; # backspace over the last character
	undef $spinning;
	$spinpos = 0;
}



