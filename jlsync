#!/usr/local/bin/perl -w


# jlsync - jlsyncronize files to many hosts from a central repository
#
# Jason Lee, jlsync@jason-lee.net.au, March 2002
#
# Copyright © 2002-2005   Jason Lee Pty. Ltd.
#
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
#
# $Id: jlsync,v 1.104 2005/12/11 22:28:42 plastic Exp $

use Readonly;
use strict;

#################### BEGIN CONFIGURATION SECTION ###########################

# path to rsync version 2.6.4 (or greater)
Readonly my $rsync => "/usr/local/bin/rsync";

# special command line options to always use with rsync
Readonly my $rsync_opts => "--rsync-path=/usr/local/bin/rsync";

# directories variables are without trailing /
# leave $jlsync_prefix set to "/jlsync" for furture upgrade compatibility
Readonly my $jlsync_prefix => "/jlsync";

# $src, $stg and $backup_dir must be on the same filesystem
Readonly my $src        => $jlsync_prefix . "/source";
Readonly my $stg        => $jlsync_prefix . "/stage";
Readonly my $backup_dir => $jlsync_prefix . "/backup";

# jlsync config file
Readonly my $config => $jlsync_prefix . "/etc/jlsync.config";

# $smtp_server is used by Mail::Mailer to send --email reports through
Readonly my $smtp_server => '127.0.0.1';

# not all filesystems are created equal. leave this set to 0
Readonly my $able_to_link_to_symlinks => 0;    # linux = 1 , solaris = 0 ;

#################### END OF CONFIGURATION SECTION ###########################

# use File::stat;		# TODO: maybe use this later.
use File::Path;
use IO::Prompt;
use Term::ANSIColor qw(:constants);
use File::Basename;
use Getopt::Long;
use Mail::Mailer;
use File::Pid;

Readonly my $MASK_RE              => qr{ \w[\w-]* }xms;
Readonly my $MASKS_RE             => qr{ $MASK_RE (:? , $MASK_RE )* }xms;
Readonly my $CONTROL_FILE_TYPE_RE => qr{ [ade] }xms;                        # Add Delete Exclude
Readonly my $CONTROL_FILE_EXT_RE  => qr{ 
        $MASKS_RE               # maska,maskb
        \.                      # . dot
        $CONTROL_FILE_TYPE_RE   # 
        \~                      # ~
    }xms;
Readonly my $CONTROL_FILE_RE => qr{ 
        .*                      # basename
        \.                      # . dot
        $CONTROL_FILE_EXT_RE    # 
        $                       # end of line
    }xms;

my $VERSION;
( $VERSION = '$Revision: 1.104 $ ' ) =~ s/[^0-9.]//g;

Readonly my $reportfrom => 'jlsync report <root>';

$| = 1;    # turn on autoflush

my $spinpos;
my $spinning;
my $spinlen;

umask 0;    # needed by subsequent mkdirs

my %paths_for;    # list of Paths for each Client

my $verbose;
my $version;
my $report;
my $email;
my $silent;
my $reporttext;
my $real;
my $get;
my $getmask;
my $nocolor;
my $unjlsyncronized = 0;
my %masks_of;
my %hosts_with;
my @pidfiles = (); # list of File::Pid objects.

GetOptions( "real"             => \$real,       # --real
            "get"              => \$get,        # --get
            "version"          => \$version,    # --version
            "verbose"          => \$verbose,    # --verbose
            "report"           => \$report,     # --report
            "email|mail=s"     => \$email,      # --email=address
            "nocolor|nocolour" => \$nocolor,    # --nocolor
            "mask=s"           => \$getmask,    # --mask=MASKNAME
            "silent"           => \$silent,     # --silent available on commandline for testing
          ) || usage();

if ($nocolor) { $ENV{'ANSI_COLORS_DISABLED'} = 'nocolor'; }

$silent = 1 if $report;

if ($version)
{
    print "jlsync version $VERSION\n";
    exit 0;
}

# check for incompatibile command line options.
if (    ( $real && $report )
     || ( $get  && $report )
     || ( $real && $email )
     || ( $get  && $email ) )
{
    usage();
}

# process remaining command line
usage() unless ( defined $ARGV[0] );

config_slurp();    # needed prior to further command line checks

while ( my $arg = shift @ARGV )
{
    usage() unless ( $arg =~ m{(.+):(/.*)}xms );
    my $clients_list = $1;
    my $path         = $2;
    foreach my $client ( matching_clients($clients_list) )
    {
        @{ $paths_for{$client}{$path} } = ();
    }
}

foreach my $client ( keys %paths_for )
{
    my $lockfile = "$stg/${client}-lock";
    my $pidfile = File::Pid->new( { file => $lockfile } );
    if ( ( -f $lockfile) && (my $another_pid = $pidfile->running) )
    {
        print "jlsync stage locked ( $lockfile ) by process id $another_pid\n";
        exit 1;
    }
    else
    {
        $pidfile->write || die "could not create lockfile: $lockfile";
        push @pidfiles, $pidfile;
    }
}

print "reading source repository image in... " unless $silent;
my %srch = srcdir($src);
nospin()        unless $silent;
print "done.\n" unless $silent;

foreach my $client ( keys %paths_for )
{
    build_image($client, "$stg/$client");
}

foreach my $client ( keys %paths_for )
{
    foreach my $path ( keys %{ $paths_for{$client} } )
    {
        my $excludepatternfile;

        if ( @{ $paths_for{$client}{$path} } )
        {
            my @excludepatterns = @{ $paths_for{$client}{$path} };

            print "exclude patterns for " . CYAN . BOLD . $client . ":" . $path . RESET . " are:\n" . ON_CYAN . "\n" . join( "\n", @excludepatterns ) . "\n" . RESET . "\n"
                unless $silent;

            $excludepatternfile = "/tmp/" . ".jlsync-" . $client . "-" . time . "-" . $$;

            open( TMP, ">$excludepatternfile" )
                || die "could not open $excludepatternfile";
            print TMP join( "\n", @excludepatterns ) . "\n";
            close TMP;
        }
        else
        {
            print "there are no exclude patterns for " . CYAN . BOLD . $client . ":" . $path . RESET . "\n" unless $silent;
            undef $excludepatternfile;
        }

        if ($get)
        {
            get( $client, $path, $excludepatternfile );
        }
        else
        {
            deploy( $client, $path, $excludepatternfile );
        }

        if ( defined($excludepatternfile) )
        {
            unlink $excludepatternfile;
        }
    }
}

foreach my $pidfile ( @pidfiles )
{
    $pidfile->remove or warn "could not unlike pid file\n";
}

if ($report)
{
    my $rl = <<END;
rsync --itemize legend: UXcstpoga
action U: <)send  >)receive  c)change/create  h)hardlink  .)attribute chanage
file-types X: f)file  d)directory  L)symlink  D)device
why: c)hecksum s)ize t)imestamp p)ermissions o)wner g)roup a)extended attribute
END

    my $runtime = time - $^T;
    $reporttext = "jlsync report at " . localtime(time) . "\n\n" . ( $unjlsyncronized > 0 ? $rl . "\n\n" : "" ) . $reporttext . "\nEnd of report. Completed in " . $runtime . " seconds.\n";

    if ($email)
    {
        my $sinfo =
            ( $unjlsyncronized > 0 )
            ? " - out of sync: " . $unjlsyncronized
            : " - fully jlsyncronized";

        my $mailer = Mail::Mailer->new( 'smtp', Server => $smtp_server );
        $mailer->open( { From    => $reportfrom,
                         To      => $email,
                         Subject => 'jlsync report at ' . localtime(time) . $sinfo
                       }
                     );
        print $mailer $reporttext;
        $mailer->close();
    }
    else
    {
        print $reporttext;
    }
}

exit 0;

# slurp in jlsync.config and populate %masks_of and %hosts_with
sub config_slurp
{
    open( CONFIG, $config ) || die "can not open $config";
    while ( my $config_line = <CONFIG> )
    {
        next if $config_line =~ /^#/;
        $config_line =~ s/\s+$//;
        my @tmasks = split( /\s+/, $config_line );
        my $this_host = $tmasks[-1];    # host is last mask on line
        if ( $tmasks[0] eq 'DEFAULT' )
        {
            if ( defined $masks_of{$this_host} )
            {
                print BOLD . RED . "Error: duplicate entires for $this_host is file $config . exiting." . RESET . "\n";
                exit 1;
            }
            else
            {
                $masks_of{$this_host} = \@tmasks;
                foreach my $mask (@tmasks)
                {
                    push @{ $hosts_with{$mask} }, $this_host;
                }
            }
        }
    }
    close CONFIG;
    return;
}

#  parse command line client part, eg. =MASKA=MASKB,hostc,=MASKD
#  and return list of matching clients
sub matching_clients
{
    my ($command_line_client_part) = @_;

    my @parts = split( ',', $command_line_client_part );
    my @clients;

    foreach my $client_part (@parts)
    {
        if ( $client_part =~ /^=(.*)/ )    # leading = is stripped off here
        {
            my @intersect_masks = split /=/, $1;
            foreach my $mask (@intersect_masks)
            {
                unless ( defined $hosts_with{$mask} )
                {
                    print "$mask not found in file $config. exiting.\n";
                    exit 1;
                }
            }

            my $firstmask = shift @intersect_masks;
            my %intersection = map { ( $_, 1 ) } @{ $hosts_with{$firstmask} };
            foreach my $mask (@intersect_masks)
            {
                print "updated $client_part intersection is now " . ( join " ", ( keys %intersection ) ) . "\n" if $verbose;
                foreach my $host ( keys %intersection )
                {
                    unless ( grep {/^$host$/} @{ $hosts_with{$mask} } )
                    {
                        delete $intersection{$host};
                    }
                }
            }

            print "for client_part $client_part intersection of matching hosts is " . ( join " ", ( keys %intersection ) ) . "\n" if $verbose;

            if ( keys %intersection )
            {
                push @clients, ( keys %intersection );
            }
            else
            {
                print "no maching clients found for intersection of $client_part . exiting.\n";
                exit 1;
            }
        }
        elsif ( !defined $masks_of{$client_part} )
        {
            print "$client_part not found in file $config. exiting.\n";
            exit 1;
        }
        else
        {
            push @clients, $client_part;    # a regular client
        }
    }

    return @clients;
}

######################################################

# data structures
#
# directory_hash =  { fileone => filehash,  filetwo => filehash }
#
# file_hash  = { 
#       lstat    => [normal lstat array],
#	    type     => "f"ile or "d"rectory or sym"l"ink,
#	    srcpath  => "/src/dir/full/path",
#
#	    dir      => directory_hash_ref ,  # only if a directory
#       readlink => "link/target" ,       # only if a a symlink
#
# considering...     control => control_hash_ref   # only if control file 
#       }
#
# to be defined...
# control_hash => {
#               a => { maska => filehash, maskb => filehash, ... }
#               d => { maska => filehash, maskb => filehash, ... }
#               e => { maska => filehash, maskb => filehash, ... }
#                 }

# srcdir( /dir/path ) returns a directory_hash rooted at /dir/path
sub srcdir
{
    my ($dir) = @_;
    my %dirh;
    local *DIR;

    #opendir(DIR,$src . "/" . $ap) || die "could not open $ap \! \n";
    opendir( DIR, $dir ) || die "could not open $dir \! \n";
    my $nextfile;
    while ( defined( $nextfile = readdir(DIR) ) )
    {
        next if $nextfile =~ /^\.\.?$/;
        $dirh{$nextfile} = { srcfile( $dir . "/" . $nextfile ) };
    }
    close(DIR);
    spin() unless $silent;
    return %dirh;
}

# srcfile( /file/or/dir/path ) returns a file_hash for /file/or/dir/path
sub srcfile
{
    my ($filename) = @_;
    my %fileh;

    $fileh{srcpath} = $filename;
    $fileh{lstat}   = [ lstat $filename ];

    if ( -f _ )
    {
        print "$filename is a file\n" if $verbose;
        $fileh{type} = 'f';
    }
    elsif ( -d _ )    # -d on symlink to a dir will succeed on linux/ext2fs
    {
        print "$filename is a dir\n" if $verbose;
        $fileh{type} = 'd';
        $fileh{dir}  = { srcdir($filename) };
    }
    elsif ( -l _ )
    {
        print "$filename is a symlink\n" if $verbose;
        $fileh{type}     = 'l';
        $fileh{readlink} = readlink($filename);
    }
    else
    {
        print "not a file, symlink or directory: $filename\n";
    }
    return %fileh;
}

# usage() print and exit.
sub usage
{
    print "jlsync usage:\n";
    print "jlsync [--real] [--nocolor] [--verbose ] client:/path/to/pushout...\n";
    print "jlsync --get [--mask=MASK] [--real] [--nocolor] [--verbose] client:/get/path...\n";
    print "jlsync --report [--email=user\@example.com] client:/report/path...\n";
    exit 1;
}

# build_image($client,$image_dir)
# build the jlsync image for $client in $image_dir
#
sub build_image
{
    my ($client, $image_dir) = @_;

    print "masks are " . BLUE . BOLD . join( " ", @{$masks_of{$client}} ) . RESET . ".\n"
        unless $silent;

    my $stgclient = "$stg/$client";
    if ( -e $image_dir )
    {
        print "deleting old image for $client in $image_dir ... " unless $silent;
        system "/bin/rm -rf $image_dir";
        if ( $? != 0 ) { die "could not /bin/rm -rf $image_dir"; }
        print "done.\n" unless $silent;
    }
    mkdir $image_dir, 0755 or die "could not mkdir $image_dir";

    print "building new image for $client in $image_dir ...\n" unless $silent;

    foreach my $path ( keys %{ $paths_for{$client} } )
    {
        @{ $paths_for{$client}{$path} } = build_path( $client, $image_dir, $path );
    }
    utime( time, ( stat($src) )[9], $image_dir );

    nospin()                                                    unless $silent;
    print "done building new image for $client in $image_dir\n" unless $silent;
}

#
#
sub build_path
{
    my ( $client, $image_dir, $path ) = @_;

    $path =~ s|^/||;

    my @excludepatterns = rbuild_path( $masks_of{$client}, \%srch, $path, $image_dir );
    @excludepatterns = map { $_ =~ s|^\Q$image_dir||; $_ } @excludepatterns;
    return @excludepatterns;
}

# rbuild_path - recursive build path
#
sub rbuild_path
{
    my $masksref = $_[0];    # reference to array of client masks as listed jlsync.config
    my $srch     = $_[1];    # reference to source hash rooted at current directory level
    my $path     = $_[2];    # string containing "remaining/path/to/process"
    my $dest     = $_[3];    # full path of destination directory for remaining build

    my @masks = [$masksref];
    my @excludepatterns;
    my $filesaref;
    my $excludearef;

    if ( defined($path) )    # still some remaining path to selectively process.
    {
        my @pcs    = split "/", $path;
        my $nextpc = shift @pcs;

        # selectively filter controlfiles....
        ( $filesaref, $excludearef ) = filtercontrolfiles( $nextpc, $srch , $masksref);

        $path = join "/", @pcs;    # remaining path.
    }
    else
    {
        ( $filesaref, $excludearef ) = filtercontrolfiles( undef, $srch , $masksref);
    }

    @excludepatterns = map { $dest . "/" . $_ } @{$excludearef};

    foreach my $srcname ( @{$filesaref} )
    {
        my $stgname = $srcname;

        if ( $stgname =~ m|(.*)\.\w[\w\-\,]*\.a\~$| )
        {
            $stgname = $1;
        }
        my $destname = "$dest/$stgname";

        if ( $srch->{$srcname}{type} eq "f" )
        {
            print "$srcname is a file\n" if $verbose;
            link( $srch->{$srcname}{srcpath}, $destname )
                || die "unable to link $srch->{$srcname}{srcpath} to $destname";
        }
        elsif ( $srch->{$srcname}{type} eq "d" )
        {
            print "$srcname is a dir\n" if $verbose;
            my ( $mode, $uid, $gid, $mtime ) = @{ $srch->{$srcname}{lstat} }[ 2, 4, 5, 9 ];
            if ( !-d $destname )
            {
                $mode = $mode & 07777;    # mask off file type
                mkdir $destname, $mode || die "unable to mkdir $destname";
                chown $uid, $gid, $destname;
            }
            push( @excludepatterns, rbuild_path( $masksref, $srch->{$srcname}{dir}, $path, $destname ) );
            utime( time, $mtime, $destname );

        }
        elsif ( $srch->{$srcname}{type} eq "l" )
        {

            # Need some special code here to handle copying or
            # hardlink of relative symlinks

            print "$srcname is a symlink\n" if $verbose;
            if ($able_to_link_to_symlinks)
            {
                link( $srch->{$srcname}{srcpath}, $destname )
                    || die "unable to link $srch->{$srcname}{srcpath} to $destname";
            }
            else
            {

                # deference symlink
                my $target = $srch->{$srcname}{readlink};

                # create new symlink like original
                symlink( $target, $destname )
                    || die "unable to symlink $target to $destname";

                # set timestamp - this doesn't work sets time stamp on target of link not symlink itself. rsync seems to be ignoring symlink timestamps anyway.
                # my $mtime =  @{$srch->{$srcname}{stat}}[ 9 ];
                # utime(time, $mtime, $destname);
            }
        }
        else
        {
            print "not a file, symlink or directory: $srcname\n";
        }
    }
    return @excludepatterns;
}

#
#
#
sub filtercontrolfiles
{
    my $basenamefilter = $_[0];
    my $srchref        = $_[1];
    my @masks          = @{$_[2]};

    my @file_list     = (keys %{$srchref} );
    my @filtered_list = @file_list;

    if ( defined($basenamefilter) )
    {
        @filtered_list = grep {/^$basenamefilter/} @filtered_list;
    }

    my @excludepatterns;

    if ($verbose)
    {
        print "filtered_list is " . ( join ",", @filtered_list ) . "\n";
    }
    else
    {
        spin();
    }

    foreach my $mask ( reverse @masks )
    {
        my @alist = grep {m/\. ($MASK_RE,)* $mask (,$MASK_RE)* \.a~$ /xms} @filtered_list;
        my $a;
        foreach $a (@alist)
        {
            nospin() unless $silent;

            # TODO : add symlink add/print case below
            print GREEN . "add:$srchref->{$a}->{srcpath}" . ( $srchref->{$a}->{type} eq "d" ? "/" : "" ) . RESET . "\n" unless $silent;
            ( my $basename = $a ) =~ s{ \. ($MASK_RE,)* $mask (,$MASK_RE)* \.a~$ }{}xms;
            @filtered_list = grep { !m/^\Q$basename\E$/ } @filtered_list;
            @filtered_list = grep { !m/^ \Q$basename\E \. $CONTROL_FILE_EXT_RE $/xms } @filtered_list;
            push( @filtered_list, $a );
        }

        my @dlist = grep {m/\. ($MASK_RE,)* $mask (,$MASK_RE)* \.d~$ /xms} @filtered_list;
        my $d;
        foreach $d (@dlist)
        {
            nospin() unless $silent;

            # bug on this next line. we want to test file type (is it a directory?) of control file target, not control file itself.
            print RED . "del:$srchref->{$d}->{srcpath}" . ( $srchref->{$d}->{type} eq "d" ? "/" : "" ) . RESET . "\n" unless $silent;
            ( my $basename = $d ) =~ s/\.( $MASK_RE ,)* $mask (,$MASK_RE )* \.d~ $//xms;
            @filtered_list = grep { !m/^\Q$basename\E$/ } @filtered_list;
            @filtered_list = grep { !m/^ \Q$basename\E \. $CONTROL_FILE_EXT_RE $/xms } @filtered_list;
        }

        my @elist = grep {m/\. ($MASK_RE,)* $mask (,$MASK_RE)* \.e~$ /xms} @filtered_list;
        my $e;
        foreach $e (@elist)
        {
            print "e~ is $e\n" if $verbose;
            ( my $basename = $e ) =~ s/\.( $MASK_RE ,)* $mask (,$MASK_RE )* \.e~ $//xms;
            @filtered_list = grep { !m/^\Q$basename\E$/ } @filtered_list;
            @filtered_list = grep { !m/^ \Q$basename\E \. $CONTROL_FILE_EXT_RE $/xms } @filtered_list;

            push( @excludepatterns, $basename );
        }
    }

    # strip out any remaining control files for other non-matched masks while preserving .a~ files.
    my @final_list = ();
    foreach my $file (@filtered_list)
    {
        if ( $file =~ /\. ($MASKS_RE) \.a \~$/xms )
        {
            my @file_masks = split( ",", $1 );
            foreach my $fm (@file_masks)
            {
                if ( grep {/^$fm$/} @masks )
                {
                    push( @final_list, $file );
                    last;
                }
            }
        }
        elsif ( $file =~ /\.[ed]\~$/ )
        {

            # must be non-matching masks.
            next;
        }
        else    # just a regular filename (i.e. not a control file)
        {
            push( @final_list, $file );
        }
    }

    print "final_list is now " . ( join ",", @final_list ) . "\n" if $verbose;
    return ( \@final_list, \@excludepatterns );
}

#
#
sub deploy
{
    my ( $client, $path, $excludepatternfile ) = @_;

    my $yes = 0;
    print "deploy: client: $client  path: $path\n" if $verbose;
    chdir "$stg/$client";
    print "pwd is now $stg/$client (staging area root)\n" if $verbose;
    if ($report)
    {
        deploy_rsync( "--dry-run", $client, $path, $excludepatternfile );
    }
    else
    {
        unless ($real)
        {
            deploy_rsync( "--dry-run", $client, $path, $excludepatternfile );

            if ( prompt( -yes1, 'Would you like to run rysnc for real? ' ) )
            {
                $yes = 1;
            }
        }
        if ( $real || $yes )
        {
            deploy_rsync( "", $client, $path, $excludepatternfile );
        }
    }
}

#
#
sub deploy_rsync
{
    my ( $dryrun, $client, $path, $excludepatternfile ) = @_;

    my $output;
    my $verbose = "";

    $verbose .= " --verbose " unless ($report);

    my $command = "$rsync $rsync_opts $dryrun $verbose --itemize-changes --compress --archive --delete --recursive --links --relative";
    $command .= " --exclude-from=$excludepatternfile"
        if ( defined($excludepatternfile) );
    $command .= " .$path $client:/";

    unless ($silent)
    {
        print( $dryrun
               ? "running dry-run for " . YELLOW . ON_BLACK . "${client}:${path}" . RESET " ...\n"
               : "running rsync for real for " . GREEN . BOLD . "${client}:${path}" . RESET . " ...\n"
             );
        print( $dryrun ? BLACK ON_YELLOW BOLD: ON_GREEN BOLD );
        print $command . "\n";
        print RESET . ( $dryrun ? BLACK ON_YELLOW: ON_GREEN );
    }

    if ($report)
    {
        $reporttext .= "$client:$path";
    }

    open( RSYNC, "$command|" ) || die 'can not open $command';
    while (<RSYNC>)
    {
        if ($report)
        {
            $output .= $_;
            print $_ if ($verbose);
        }
        else
        {
            print $_;
        }
    }
    close RSYNC;
    print RESET . "\n" unless $silent;

    if ($report)
    {
        if ($output)
        {
            $unjlsyncronized++;
            $output =~ s/^/ /mg;
            $reporttext .= "\n\n" . $output . "\n";
        }
        else
        {
            $reporttext .= "  -  jlsyncronized\n";
        }
    }
}

#
# get( $client, $path)
sub get
{
    my ( $client, $path, $excludepatternfile ) = @_;

    my $target;
    my $cgetmask;    # client get mask
    my $stggetroot    = $stg . "/" . $client ;
    my $stgget        = $stg . "/" . $client . $path;
    my $srcget        = $src . $path;
    my $stggettmp     = $stg . "/" . $client . "-get";
    my $stggettmppath = $stggettmp . $path;

    # if no getmask is supplied then $client is used.
    if ( !$getmask )
    {
        $cgetmask = $client;
    }
    else
    {
        $cgetmask = $getmask;
    }

    if ( $cgetmask eq "DEFAULT" )
    {
        $target = $src . $path;
    }
    else
    {
        if ( !grep {/^\Q$cgetmask\E$/} @{ $masks_of{$client} } )
        {
            print BOLD . BLACK . ON_YELLOW . "WARNING client $client is currently not subscribed to mask $cgetmask\n" . RESET;
        }
        $target = $src . $path . "." . $cgetmask . ".a\~";
    }

    # TODO: what is the --backup stragegy here????
    # TODO: considier --link-dest instead of --copy-dest?

    my $command = "$rsync $rsync_opts --compress --itemize-changes --archive --delete --copy-dest=$stggetroot --backup --backup-dir=$backup_dir --links --recursive --relative --verbose";
    $command .= " --exclude-from=$excludepatternfile"
        if ( defined($excludepatternfile) );
    $command .= " $client:$path $stggettmp";

    print "collecting remote files...\n" . BOLD . BLACK . ON_YELLOW . $command . "\n" . RESET . BLACK . ON_YELLOW;
    system $command;    # todo check return code
    print RESET . "\n";

    if ( !-e $stggettmppath )
    {
        print BOLD . RED . ON_WHITE . "Error: nothing collected from $client:$path \nplease check that remote path contains no symlinks" . RESET . "\n";
        return;
    }

    # full path search to determine repository original version...

    my ( $ap , $found ) = locate_path($path, \%srch, $client);     # accumulated path


    print "Accumlated path is $ap\n" if $verbose;
    print "Was the target path found in the source repository?: $found\n"
        if $verbose;

    my $srcap = $src . $ap;

    # maybe need to add check if a directory is being replaced with a file.
    # decide what to do, then...

    # symlink up again? or use rdist?

    my $possiblesource2;
    my $possiblesource;

    if ( $found eq 'yes' )
    {
        print "current source repository ( $src ) version...\n";
        my $confirmed = '';

        if ( -f $srcap )
        {
            if ( ( stat($stgget) )[1] == ( stat("$srcap") )[1] )
            {
                $confirmed = "(confirmed)";
            }
            else
            {
                $confirmed = "(warning: source and stage inode mismatch)";
            }
        }
        my $nfiles = "";
        if ( -d $srcap )
        {
            $nfiles = `find $srcap -print | wc -l`;
            $nfiles =~ s/\D//g;
            $nfiles = "( number of files: $nfiles )";
        }
        print ON_WHITE . BLUE . "$srcap $confirmed $nfiles" . RESET . "\n";
        chdir dirname($srcap);
        print GREEN;
        system "ls", "-ld", basename($srcap);
        print RESET;
    }

    if ( -e $stgget )
    {
        print "current stage area ( $stg ) version for $client is\n";
        my $nfiles = "";
        if ( -d $stgget )
        {
            $nfiles = `find $stgget -print | wc -l`;
            $nfiles =~ s/\D//g;
            $nfiles = "( number of files: $nfiles )";
        }
        print ON_WHITE . BLUE . "$stgget $nfiles" . RESET . "\n";
        chdir dirname($stgget);
        print GREEN;
        system "ls", "-ld", basename($stgget);
        print RESET;
    }

    if ( -e $target && ( $target ne $srcap ) )
    {
        print "current repository target version is\n";
        my $nfiles = "";
        if ( -d $target )
        {
            $nfiles = `find $target -print | wc -l`;
            $nfiles =~ s/\D//g;
            $nfiles = "( number of files: $nfiles )";
        }
        print ON_WHITE . BLUE . "$target $nfiles" . RESET . "\n";
        chdir dirname($target);
        print GREEN;
        system "ls", "-ld", basename($target);
        print RESET;
    }

    print "remote ( $stggettmp ) version just got is...\n";
    my $nfiles = "";
    if ( -d $stggettmppath )
    {
        $nfiles = `find $stggettmp -print | wc -l`;
        $nfiles =~ s/\D//g;
        $nfiles = "( number of files: $nfiles )";
    }

    print ON_WHITE . BLUE . "$stggettmppath $nfiles" . RESET . "\n";
    chdir dirname($stggettmppath);
    print GREEN;
    system "ls", "-ld", basename($stggettmppath);
    print RESET;

    my $yes = 0;
    unless ($real)
    {
        print "this will be copied to...\n";
        print ON_WHITE . BLUE . $target . RESET . "\n";
        if ( prompt( -yes1, 'would your like replace files for real? ' ) )
        {
            $yes = 1;
        }
    }

    # TODO: it would be nice to preserve control files in any
    # subdirectories in the repository....

    # TODO: need to preserve ownership & permisions of parent directories.

    if ( $real || $yes )
    {
        print ON_GREEN . "updating " . ON_WHITE . BLUE . $target . RESET . ON_GREEN . "... ";
        print "rmtree($target)\n" if ($verbose);
        rmtree($target);
        print "mkpath" . dirname($target) . "\n" if ($verbose);
        mkpath dirname($target), 0, 0755;
        print "rename($stggettmppath, $target)\n" if ($verbose);
        rename( $stggettmppath, $target )
            || die "unable to rename $stggettmp to $target";
        print "done." . RESET . "\n";
    }

}

# locate_path($path) in from src_hash and return /src/path and found?yes|no
sub locate_path
{
    my ($path, $srch_ref, $client ) = @_;

    return "" if ( !defined($path)) ;

    my @pcs    = split "/", $path;

    my $tap = "";
    my $srch = $srch_ref;

    PATHLOOP: foreach my $pc (@pcs)
    {
        my ( $filesaref, $excludearef ) = filtercontrolfiles( $pc, $srch , $masks_of{$client});
        my $matching_pc = ${$filesaref}[0];

        $tap .= $matching_pc;

        if ( $srch->{$matching_pc}{type} eq "f" )
        {
            print "matching_pc $matching_pc is a file\n" if $verbose;
            last PATHLOOP;
        }
        elsif ( $srch->{$matching_pc}{type} eq "d" )
        {
            print "matching_pc $matching_pc is a dir\n" if $verbose;

        }
        elsif ( $srch->{$matching_pc}{type} eq "l" )
        {
            print "matching_pc $matching_pc is a symlink\n" if $verbose;
            # deference symlink
            my $target = $srch->{$matching_pc}{readlink};
            last PATHLOOP;
        }

        $srch = $srch->{$matching_pc}{dir}; 
    }

    return [ $tap, "yes" ];
}


# spin code taken from http://dreamscape.org/code/spin - slf@dreamscape.org - steven fountain
sub spin
{
    return if $silent;

    #my @spinchars = qw(. o O o);
    my @spinchars = qw(- / | \\);
    $spinlen = @spinchars;                   # count chars to spin
    $spinpos = 0 unless defined $spinpos;    # initialize spin position
    print "\b" if $spinning;                 # backspace over the last character
    $spinning = 1 unless defined $spinning;  # is this the first run?
    print "$spinchars[$spinpos]";            # print the spin character
    $spinpos++;                              # increment the spin position
    $spinpos = 0 if ( $spinpos >= $spinlen );    # start over if no more chars
}

sub nospin
{
    return     if $silent;
    print "\b" if $spinning;                     # backspace over the last character
    undef $spinning;
    $spinpos = 0;
}

###################### MANPAGE ########################################

=head1 NAME

jlsync - rsync wrapper to deploy files from a central repository to
         client hosts and for ongoing configuration management.

=head1 SYNOPSIS

 jlsync [--real] [--nocolor] [--verbose] clienthost:/path/to/pushout 
         [clienthost2:/another/path2/pushout]...

 jlsync --get [--real] [--mask=NAME] clienthost:/path/to/pullin
         [clienthost2:/another/path2/pullin]...

 jlsync --report [--email=address] clienthost:/path/to/check 
         [clienthost2:/another/path2/check]...

=head1 VERSION

This documentation refers to jlsync version 2.0. ($Revision: 1.104 $)

=head1 DESCRIPTION

jlsync is a rsync wrapper that allows files and directories to be
syncronised from a central repository to many client hosts. jlsync can
be used for initial installation and also for ongoing configuration
managment. Files can be grouped into file templates that individual
client hosts can "subscribe" to. jlsync works well with ssh key
authentication to avoid rsync over ssh being prompted for remote client
root passwords.

=head1 OPTIONS

C<--nocolor> turns of color text highlighting. By default rsync commands
and other actions are highlighted in different colors.

C<--verbose> turn on more debug output.

C<--get> pull files from the remote client into the repository (instead
of the default behaviour which is to push out files form the
repository).

C<--real> do not prompt for confirmation of actions. Use this option
with caution!

C<--mask=template_name> when pulling files from a remote client put them
into the repostitory with and add mask of template_name.

C<--report> print out a report of differences between client pathnames
and staging image taken using the rsync --dry-run output.

C<--email=address> Report is emailed to the email address "address"
instead of being printed out.


=head1 BASIC USAGE

To distribute /usr/java from the repository to a host called jav04
run the following commands:

First run

 jlsync jav04:/usr/java  

this will build a staging image for jav04 and then do a rsync --dry-run
of C</usr/java> to jav04. Look closely at the output to verify the
additions and deletions on the remote host are as expected. You will
then be prompted with "would you like to run rsync now for real? ".
Answer yes to run rsync again without the --dry-run rysnc option (ie. go
ahead and make changes to client for "real").

Only if you're 100% sure that jlsync is going add and delete
the correct files you can run with the C<--real> option

 jlsync --real jav04:/usr/java

when the C<--real> option you are not prompted and rsync to the client
does not use the rsync --dry-run option. BE CAREFUL, incorrect usage or
incorrect configuration in the repository could easily result in the
permanent deletion of important files on the client.

=head2 Getting remote files into the repository

To quickly gather files and/or directories from a remote host back 
into the repostory the C<--get> option can be used. 
A specific template for the gathered files can be named with the
C<--mask> option.  For example to get a freshly installed httpd binary
back from client host web01 into the repostory for the file template
"WEBSERVERS" run

 jlsync --get --mask=WEBSERVERS web01:/usr/local/apache/bin/httpd

This will result in C<usr/local/apache/bin/httpd.WEBSERVERS.a~> being
added to the repostitory.  Once the file is in the repository it can be
deployed to other clients that subscribe to the WEBSERVERS template.

Files can be gathered into the special DEFAULT file template

 jlsync --get --mask=DEFAULT  holly:/usr/local/bin/rsync

will result in C<usr/local/bin/rsync> being added to the repostitory.

When a C<--mask> option is not given gathered files will be added to the
clients own host template. e.g.

 jlsync --get goanna:/etc/hosts

would result in C<etc/hosts.goanna.a~> being added to the repository. 

=head2 The config file

Each client host has an entry in the C<jlsync.config> file that lists
the file templates that it subscribes to. A template is made up of
files and control files in the repository that share same template/mask
name.  Using templates is a convenient way of grouping files that
should only be deployed to a certain category of hosts such as "web
servers" or "database servers".

Every client must subscribe to the base template called DEFAULT.  Also
each client also must subscribe to a template that is the same as that
client's hostname.

Templates filesets are layered one upon another to build the jlsync
client image in the staging area before the image is rsync'ed to the
client.  The control files for templates are applied in reverse order
as they are listed in the control file, ie. right to left. So when
multiple control files with the same basename exist the most
significate control file is used. Hostname control files are always the
most significant and the DEFAULT control files are always the least
significant.

The following example C<jlsync.config> entry shows a host, jav04, entry
that only contains the minimum of the DEFAULT template and it's own
template.

 DEFAULT	jav04

The next example C<jlsync.config> entry shows a host, www05, who's final
file image is made up of 3 additional file templates

 DEFAULT WEBSERVERS prodservers london www05

=head2 The respository 

All the files for the all the file templates are stored in the
repostitory under the same directory root. Control files for
different templates are named with filename suffix C<.templatename.X~>
notation. Files in the DEFAULT template don't need the suffix notation.

=head2 Control Files


=head3 the Add .templatename.a~ controlfile

Files and/or directories from the repository for a given template with
with Add control file suffix, C<.templatename.a~> , get added to the final
staging image for clients that subscribe to I<templatename>.

=head3 the Delete .templatename.d~ controlfile

If a file with the Delete control file suffix exists in the repository
then the corresponding file or directory with the same basename will
not be added the staging image for that client.

Rsync will delete files on remote hosts that aren't found in the local
file image (that is unless they have also been excluded from the rsync
comparision).

The easiest way to create Delete and Exclude control files is to simply
"touch" them.

=head3 the Exclude .templatename.e~ controlfile

Files with Exclude suffix, C<.templatename.e~> , are added to the list
of files to be excluded from the rsync comparision. Any files or
directories that are excluded will not be deployed from the staging
area or updated/deleted from the client host.

The following Exclude file will cause the C</var/run/sendmail.pid> file
to be be ignored (left alone) by the rsync for all client hosts


 /var/run/sendmail.pid.DEFAULT.e~

This next exclude bontrol file will cause the entire C</var/mysql>
directory to be ignored for any client hosts that are listed with the
"databaseservers" template in the jlsync.config file.

 /var/mysql.databaseservers.e~

Exclude control files can also contain regular expressions (as defined
and used by rsync) to match multiple files. For example, to exclude any
file ending in .pid in C</app/sendSMS> use

 /app/sendSMS/*.pid.DEFAULT.e~

To exclude the syslogd messages files (messages, messages.1, etc.) you
could use

 /var/log/messages*.DEFAULT.e~

To exlude all files in a directory (but make sure the directory is part
of the template) use something like

 /var/mysql/*.databaseservers.e~

=head1 ADVANCED USAGE

Multiple files from the same client can be deployed at the same time
	
 jlsync jav04:/etc/passwd jav04:/etc/shadow

this style of usage is useful when base directory of the files is not
fully syncronised with the repository. It's also quicker than two
individual invocations of jlsync as the staging image is only built
once.

Multiple clients can be deployed in a single command

 jlsync jav03:/opt/apache jav04:/opt/apache

with this sytle of usage the staging image for each client will be
built first before files are deployed.

Any combination of host:/path arguments can be used on the jlsync 
command line. e.g.

 jlsync db01:/u01 nfs1:/export anyhost:/any/path

=head2 Advanced Control Files

A control file can belong to multiple masks at once by separating the
masks with a comma "," e.g.

 /opt/apache.www3,www4.a~
and
 /etc/motd.INTERNAL,EXTERNAL,DMZ.e~

=head2 Advanced command line with multiple hosts

When the same path needs to be jlsynced to multiple hosts those hosts 
can given as a single comma separated list prior to the path. e.g.

 jlsync sol01,sol02,sol03,sol04,sol05,sol06,sol07:/opt/csw

=head2 Advanced command line with matching template/mask names

The C<=templatename:/path> command line notation can be used to match
all hosts that "subscribe" to that templatename in the jlsync.config
file. For example to select all hosts that have the SOLARIS template
listed in as part configuration in jlsync.config the following could be
used.

 jlsync =SOLARIS:/etc/nscd.conf

And because all hosts must subscribe to the DEFAULT template the
following will jlsync to all configured hosts

 jlsync =DEFAULT:/etc/issue

It's possible to get the intersection of muliple templates by chaining
them together. For example the following would match all production
debian hosts in newyork

 jlsync =PROD=DEBIAN=newyork:/usr/local/etc/timezone

To get the union of multiple templates you can separate them by
commas.  e.g. All hosts in London and Melbourne

 jlsync =LONDON,=MELBOURNE:/etc/passwd =LONDON,=MELBOURNE:/etc/shadow

=head1 REPORT OPTION

Ad-hoc filesystem changes made on a client can cause it's configuration
to "drift" away from it's jlsync repository configuration. The
C<--report> option can help maintain discipline over client and jlsync
repository changes by reporting any differences found. e.g.

 jlsync --report bill:/usr/local ben:/usr/local

will generate an onscreen report of changes between the C</usr/local>
directors on clients bill and ben and the repository. Using the
C<--email> option will cause the report to be sent via email e.g.

 jlsync --report --email=admin@company.com mailhub:/etc/mail

Scheduling jlsync reports in cron can be a useful way to keep an eye on
client/repository drift.

=head1 ABSOLUTELY NO WARRANTY

Because the program is licensed free of charge, there is no warranty
for the program, to the extent permitted by applicable law. Except when
otherwise stated in writing the copyright holders and/or other parties
provide the program "as is" without warranty of any kind, either
expressed or implied, including, but not limited to, the implied
warranties of merchantability and fitness for a particular purpose. The
entire risk as to the quality and performance of the program is with
you. Should the program prove defective, you assume the cost of all
necessary servicing, repair or correction.

In no event unless required by applicable law or agreed to in writing
will any copyright holder, or any other party who may modify and/or
redistribute the program as permitted above, be liable to you for
damages, including any general, special, incidental or consequential
damages arising out of the use or inability to use the program
(INCLUDING BUT NOT LIMITED TO LOSS OF DATA or DATA BEING RENDERED
INACCURATE or losses sustained by you or third parties or a failure of
the program to operate with any other programs), even if such holder or
other party has been advised of the possibility of such damages.

=head1 BUGS

yes there are few bugs. 

=head1 SEE ALSO

The rsync(1) man page.
The jlsync website http://www.jlsync.com/

=head1 AUTHOR

Jason Lee

=cut

